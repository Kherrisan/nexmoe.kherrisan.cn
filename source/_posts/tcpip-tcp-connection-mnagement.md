---
title: TCP/IP协议 TCP Connection Mnagement
categories:
  - TCP/IP
tags:
  - TCP/IP
  - 网络
copyright: true
url: 213.html
id: 213
abbrlink: b225a4eb
date: 2017-07-27 21:39:01
---

因为TCP是一个面向连接的协议，所以建立释放连接的过程是很重要的。

连接的建立和释放
--------

[![https://gyazo.com/66f8ad95b3aa6fc3f89f62f768d1a6d3](https://i.gyazo.com/66f8ad95b3aa6fc3f89f62f768d1a6d3.png)](https://gyazo.com/66f8ad95b3aa6fc3f89f62f768d1a6d3)

<!-- more -->

### 三次握手

1.  c发送一个syn被置位的报文给s，表示想要建立连接，当然这个报文包含了c的ISN。
2.  s接收到了syn报文，需要确认收到了syn和c的ISN，所以回复一个syn，同时ack置位，确认号为c的ISN+1，当然这个报文包含了s自己的ISN。
3.  c接收到了s回复的syn报文，需要确认收到了s发来的syn和s的ISN，于是c回复确认，确认号为s的ISN+1。

至于为什么要三次握手，一次两次不行呢。我是这样理解的：1次握手相当于承认传输信道的绝对可靠，就是说c发送的syn报文s绝对能收到；2次握手的话最多只能确保一个方向上的传输成功了，即c知道s能收到自己的消息，但s不知道c能不能收到自己的消息，因为s发送的syn报文还没有得到c的确认回复呢。逼乎上也有人说这是不可靠信道上要想建立双向通信必须要三次，不是说TCP/IP比较特殊要3次。

### 四次分手

1.  c的应用程序要求close，c发送一个fin报文表示自己已经没有数据要发送了，等待s的确认。
2.  s收到了c的fin报文，就好像c说自己想睡觉了，s也不能强求他吧。s只好确认c的fin报文。
3.  此时c已经没有数据要发送了，但是s说不定还有，所以s可以继续想c发送数据，而且此时的c还可以接收数据并且确认s的报文，即发送ack报文。此时TCP连接处于半开状态。
4.  s也没有数据要发送了，于是s也发送了fin报文，这个fin报文的顺序号可能比2中的确认报文的顺序号大一些，确认号应该和2中的确认号是一致的。
5.  c确认s的fin报文，回复ack，TCP连接的另一半也关闭了。至此TCP连接彻底关闭。

注意：第2个报文和第3个报文有时可以合并为同一个报文。

> #### 但是为什么书上的四次分手中，第4个ack报文的顺序号还比第3个报文的确认号小1，我还没搞清楚。

### 半关闭

TCP的四次分手其实可以看做两个半关闭，一个fin报文关闭一个方向，关闭一半的连接。socket是支持半关闭的（shutdown()），close（）是全关闭。

### 初始顺序号

初始顺序号的选择也是挺重要的，因为这关系到很多方面的问题，比如在上次连接中发出的一个迷失在网络中的报文，在这次连接中突然出现了，然后他的顺序号正好合适，于是他就上位了，这样的情况。再比如有人能够伪造合适的顺序号来实现欺骗。实际上ISN的生成好想是取时间和随机数相结合，既能随时间增长，又能有一定的随机性，不容易让人猜对。

### 建立连接时超时了

建立连接时，发出了syn报文之后c不会无限制地等待s的ack，通常会隔一个特定的时间发送一个syn，当次数超出限制之后，则说明timeout了。当然了这两个参数都是可以改的。

TCP Options
-----------

[![https://gyazo.com/bbbdbd85b890268f61cb1e02e272fbcd](https://i.gyazo.com/bbbdbd85b890268f61cb1e02e272fbcd.png)](https://gyazo.com/bbbdbd85b890268f61cb1e02e272fbcd) TCP的options字段包含了一系列的可选项，除了EOL和NOP这两个选项是只占1个字节之外，其余的选项至少占2个字节：1个字节的kind和1个字节的Length，每种选项的长度都是不定的。

### MSS最大报文长度

在syn报文中使用的选项。规定了自己能够接收的最长的报文长度，不包括TCP头部和IP头部，仅仅是data的长度。 典型的长度1460，加上TCP和IP的报文头正好1500个字节。

### SACK选择确认

在syn报文中需要明确SACK permitted，然后在后续的报文中就可以使用选择确认。当没有按照顺序收到报文时（比如收到了1，2，然后立刻收到了5），会标注选择确认。一个SACK块包含两个4字节的数（1个上界顺序号1个下界顺序号）。SACK能够显著地提高效率，和累积确认相比显得更加有效。

### 窗口大小放大

只能在syn报文中使用的选项。窗口大小缩放因子，能够把16bit的窗口大小放大到16bit-30bit的大小。假设放大因子是s的话，那么实际的窗口大小就是header的窗口大小左移s位。 使用放大因子选项的要求还是挺严格的：c发送的syn报文中包含window scale factor，s的syn+ack报文也必须要明确这一个选项，但是大小可以不同。这样就有两个scale。 不太好理解的是window advertisement的时候，假设有一个因子s用来发送窗口大小，有一个因子r来接收窗口大小，那么一旦收到了window advertisement，那么自己的window就要调整成header的window大小左移r位，每次发送window advertisement时，window header中的size就应该是自己实际的window size右移s位。 window scale shift count是由TCP自动选择的，缩放的程度取决于系统buffer的大小，当然这个是可以调的。

### Timestamp时间戳和PAWS

常用的options，而且不是只能在syn报文中使用。可以用来粗略地估计RTT，进而动态调整超时重传的时间（这个以后还会细讲）。一个时间戳4字节。发送者把自己这边的时间放在TSval，接收者收到后TSval填写自己的时间戳，TSecr抄一遍发送者的时间戳，这样每次都是抄一半写一半。 时间戳选项一般10个字节（4+4+1+1）。 接收者并不在乎发送者的时间戳的单位是什么，时间戳对于一方的意义仅仅在于能够比较大小，因此时间戳只要单调递增就可以了。 Protection Against Wrapped Sequence Number（PAWS），依靠时间戳的单调递增性，可以用来判断两个相同的顺序号的报文的先后。因为顺序号是循环递增的，因此当窗口极大时还是有可能出现前一个周期内有一个包丢了，后一个周期的相同顺序号的包上位了的现象。如下图所示： [![https://gyazo.com/daa113ddcc5688f9478338401a11b137](https://i.gyazo.com/daa113ddcc5688f9478338401a11b137.png)](https://gyazo.com/daa113ddcc5688f9478338401a11b137)

> #### 问题：万一时间戳也循环递增，顺序号和时间戳同时重复了呢。

### UTO

User Time Out，这个选项刚出不久，比较新，没有被广泛的使用。我也没看懂。。。

### TCP-AO

Authentication Option，用来认证加密的，需要事先协商一些加密函数和key，然后在options中附加上traffic key，由这个key发送者和接受者都能够产生正确的解密key。没有被广泛的使用。 不过这是一种对于TCP sproofing attack强有力的反制措施。

实例分析1
-----

随便发了个HTTP请求，把数据包抓了一下，主要就是看一看三次握手的部分。 ![](https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2017-10-18_12-08-11.png)

TCP状态转换
-------

一个TCP连接的每一端的状态都会在下面这张图中转换。有的转换是由于收到或者发送了包含状态位的报文而产生的，有的转换则是定时器超时导致。 ![](https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2017-10-18_13-59-58.png) 其实CLOSED并不是一个官方的状态，但是这里把CLOSED作为起点能够更加清晰明了地介绍TCP连接的状态转换关系。 图中有2点没有写出来的需要额外注明：

1.  CLOSED->SYN_SENT在TCP协议中是合法的，但是Berkeley SOcket中没有实现，而且也很少见到。
2.  从SYN\_RCVD->LISTEN的转换，要求必须要该SYN\_RCVD状态是由LISTEN转换而来才行，这时如果收到RST报文而不是ACK，那么又会回到LISTEN。这种转换在同时打开（simultaneous open）得情况下是不行的。

把三次握手和四次挥手的图与状态相结合，如下。 ![](https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2017-10-18_14-14-43.png)

### TIME_WAIT状态（2 MSL 等待）

由于IP报文头部的TTL和跳数限制，一个数据包在网络中的生存时间是有一个最大值的，当然这个最大值是可以配置的。 一个主动关闭的TCP在TIME_WAIT状态下必须等待两个MSL（Maximum Segment Lifetime）的时间。原因是： 1. 他将在这2MSL的时间内等待被动关闭放有么有再次发送FIN，如果收到了FIN，说明他发的ACK没有被对方接收到，那么他将会重新发送最终的ACK。 2. 2MSL中，显然连接还没有完全关闭，因此TCP出于合理性和安全性，将在2MSL状态下的连接（4元组）都定义为不可用的。除非通过最高序列号和时间戳进行分辨。否则就会出现另外一个恰巧端口号相同的连接发送的报文“小三上位”的情况。更加严格的规范是，只要两端有一方是在2MSL状态中，那么端口就不可用。 实际上的表现是：客户端断开一个连接后，立刻要求以相同的端口号建立一个新的连接，这时候会报错：Address already in use。

### FIN\_WAIT\_2

当主动关闭方发送了FIN并收到了ACK后，会进入FIN\_WAIT\_2状态。这时连接是处于半关闭的，并且被动关闭放还是可以发送数据的，只要双方愿意，可以永远保持这种状态。 因此有人设计了这样的规则，如果应用程序表明了完全关闭，那么进入到FIN\_WAIT\_2状态后会启动一个定时器，时间到了就会CLOSE。

### 同时打开和同时关闭的转换

状态图上有写，这里就不赘述了。

RST报文
-----

### 端口不存在

Connection Refused.

### 终止一条链接

比如用户忽然ctrl+c，这时所有排队的数据都会被丢弃，一个RST报文会被发送出去。同时另一方看到了RST也会采取终止操作而不是正常的关闭操作。 从某种程度上说RST报文应该是最后一个报文，因为他不会要求另一方回复任何消息，包括ACK。

### 半开链接

如果存在一个半开链接。比如客户机连上服务器后忽然断电，客户机重启后一无所知，但是服务器以为客户机还在连接中。此时服务器向客户机发送数据，此时客户机理应回复RST。

### 时间等待错误

![](https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2017-10-18_15-31-54.png) 主动关闭方在2MSL中收到了本应该在之前收到的报文，回复了ACK，但是此时恰好被动关闭方已经CLOSE，已经失去了所有关于此连接的信息，一无所知的被动关闭方收到了这个不明所以的ACK，只能回复一个RST，**而这个RST会导致主动关闭方提前CLOSE**。

TCP服务器选项
--------

在绝大多数运行的服务器上，服务器程序会监听某一个端口，当有新的连接到来时，建立一个新的进程或者线程来处理他，通常这个线程（进程）会启动一个socket。 以ssh为例，主进程监听22端口，当一个新的连接到来时，创建一个新的线程和socket，这个socket的状态为established。主进程继续监听。 ![](https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2017-10-21_19-23-04.png) 途中的本地ip地址和远程ip地址都是通配符，没有限制。

### 将要到来的连接队列

为了解决当主进程正在创建一个新的socket的同时，又有多个SYN报文同时到达的情况，TCP中设计了一个队列来进行排队管理。 从服务端来看，一个新的连接具有两种状态（见状态图）： 1. SYN_RCVD 收到了SYN，发送了SYN+ACK，等待客户端回复ACK的阶段。 2. ESTABLISHED 收到了ACK，完成了三次握手的最后一次，但是**还没有把连接交付给应用程序的阶段**。 在现代linux内核协议栈中，应用程序能够控制第二个队列的最大数量。 在linux中，有如下的规则： 1. 当新的连接的SYN报文到来时，如果SYN_REVD状态的连接数超过某个规定值，拒绝该连接。 2. 应用程序能够规定一个backlog，来限制第二阶段的连接数量，当然这个backlog也是有（操作系统规定的）最大值的限制的。 3. 如果有剩余空间，那么TCP会ACK新来的SYN。如果TCP还没有将连接交给应用程序，那么此时收到的数据会被TCP缓存。 4. 如果没有剩余空间了，那么TCP会延迟这个连接，来个应用程序一个跟上的机会。除了Linux。 按照正常的TCP机制，当第二阶段的队列已满时，应该让客户端超时，而不是像Linux一样发送RST报文。 如果服务器应用程序想要拒绝一个连接，别无他法，只能在连接建立之后发送FIN，拒绝三次握手不是他所能涉足的操作。

### 与TCP连接管理相关的攻击

SYN flood，sequence number attack等。