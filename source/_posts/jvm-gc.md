---
title: JVM——垃圾收集（GC）和内存分配
categories:
  - JVM
tags:
  - java
  - jvm
copyright: true
url: 740.html
id: 740
abbrlink: 2118eccf
date: 2018-05-06 11:04:37
---

GC日志
====

JVM可以输出GC日志供开发者分析GC过程。 -XX:+PrintGC 输出GC日志 -XX:+PrintGCDetails 输出GC的详细日志 -XX:+PrintGCTimeStamps 输出GC的时间戳（以基准时间的形式） -XX:+PrintGCDateStamps 输出GC的时间戳（以日期的形式，如 2013-05-04T21:53:59.234+0800） -XX:+PrintHeapAtGC 在进行GC的前后打印出堆的信息 -Xloggc:../logs/gc.log 日志文件的输出路径

<!-- more -->

垃圾的定义
=====

在Java中，要定义一个堆中的对象是垃圾的方法是判断是否通过全局中所有的引用都无法接触到这个对象，如果是，说明这个对象再也不可能被建立新的引用，即没有存在的意义，因为对象存在就是要被引用到。因此它就是个垃圾。

引用计数（Reference Counting）
========================

引用计数是不可能引用计数的，这辈子是不可能引用计数的。引用计数无法解决循环引用的问题。

可达性分析（Reachability Analysis）
============================

![](https://oss.kherrisan.cn/Snipaste_2018-05-06_11-14-44.jpg) 从一些被视为GC Root对象开始，从这些节点开始向下搜索，搜索经过的路径被称作引用链，如果一个对象到GC Roots没有任何引用链相连（不可达），就说明这个对象是个垃圾。 GC Roots包含以下几种对象：

1.  虚拟机栈中：引用对象（本地变量表）
2.  方法区中：类静态属性引用的对象
3.  方法区中：常量引用的对象
4.  本地方法栈中：JNI引用的对象

同时JVM更加细粒度地区分了引用的强弱：

*   强引用：类似于Object obj=new Object();
*   软引用：有用但非必须的对象。被软引用的对象不会被首先考虑回收，只有在第一轮回收之后内存仍然可能溢出的时候才会将软引用的对象纳入回收范围。
*   弱应用：在下一次垃圾回收的时候都会被回收掉。
*   虚引用：虚引用对象对于对象的生命周期（何时被回收）不会产生任何影响，有时仅仅是为了使虚引用对象能够在被回收的时候收到系统的一个通知。

需要注意的是，GC Roots实际上是一组被特殊对待的指针。没有任何对象能够引用GC Roots。

> GC Root在对象图之外，是特别定义的“起点”，不可能被对象图内的对象所引用。 一个常见的误解是以为GC Root是一组对象。 实际情况是GC Root通常是一组特别管理的指针，这些指针是tracing GC的trace的起点。它们不是对象图里的对象，对象也不可能引用到这些“外部”的指针，所以题主想像的情况无法成立。 另外，tracing GC能正确处理循环引用，保证每个活对象只会被访问一次就能确定其存活性。对象图里是否存在循环引用，tracing GC都能正确判断对象的存活与否。
> 
> 作者：RednaxelaFX 链接：https://www.zhihu.com/question/29218534/answer/43580432 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

生存还是死亡
======

一个对象被回收需要经历两次标记过程：

1.  某次可达性分析发现该对象不可达。被标记后，JVM会将该对象加入到一个队列中，同时在一个优先级较低的线程运行该对象的finalize方法（但并不保证finalize方法会执行完成）。
2.  对该队列中的对象做一次小规模的可达性分析，并标记不可达的对象。

回收方法区
=====

由于和堆区性质不同，有很多人认为方法区的对象是不会被回收的，然而事实并不是这样。JVM规范中没有规定方法区一定要GC，但实际上，面对大量使用反射、动态代理等字节码技术，JVM是需要在方法区做GC的。 方法区垃圾回收的效率一般较低，远不如堆区每次能够释放百分之七十以上的空间。 方法区主要回收两部分内容：

1.  废弃的常量：标记的方法和堆区的变量类似。
2.  无用的类：一个类是无用的有三个条件：该类所有实例都已经被回收；ClassLoader已被回收；Class对象没有在任何地方被引用，也无法再任何地方通过反射获取。当满足这三个条件，则说明该类可以被回收，但是否会采取措施进行回收还是要看JVM的参数。

垃圾收集算法
======

标记-清除（Mark-Sweep）
-----------------

这是最原始也是最基础的方法，先扫描内存空间中的所有对象，对其中应该回收的进行标记。然后释放所有被标记对象所占用的空间。 两个缺点：

1.  效率不高。
2.  会在内存空间产生大量的不连续的碎片。

复制（Copying）
-----------

将内存分为两块，每次只使用其中的一块。当被使用的块发生了GC之后，将其中剩余的对象复制到另一个块中，同时紧密排列存活的对象。 这样做的优点是对内存的空间管理（已用部分和剩余部分）非常简单易操作。缺点是牺牲了一半的内存空间的可用性。 实际应用中，新生代都是使用这种方法进行垃圾收集的。而且有聪明的人发现，新生代中，98%的对象的生命周期非常的短暂。因此可以采取如下做法： ![](https://oss.kherrisan.cn/Snipaste_2018-05-06_13-27-10.jpg) 如上图所示，新生代被分成三个部分，一个较大的区域名为Eden，另两个较小的且大小相等的区域名为Survivor。每次使用Eden和其中一块Survivor，当发生GC后，将Eden和Survivor中的存活对象复制到另一个Survivor中，最后清理掉Eden和Survivor中用过的空间。

标记-整理（Mark-Compact）
-------------------

在标记-清除的基础上，每次GC后重新排列存活的对象，使其位于内存的一端。

分代收集（Generational Collection）
-----------------------------

其实这只是一种内存分配规划思路，将内存分为新生代和老年代，对于不同的代采取不同的垃圾收集算法。

垃圾回收分类
------

*   MinorGC（新生代GC）
*   MajorGC/FullGC（老年代GC）

HotSpot算法实现
===========

枚举根节点
-----

要做GC扫描的话，就需要从每个GC Root出发，追踪所有引用的对象。可作为GC Roots的对象主要是方法区的常量或类静态属性，以及栈中的局部变量表，因此如何高效的表里局部变量表也是十分重要的。 为了避免在整个方法区或者栈中遍历寻找GC Roots，JVM维护了一个表（Oopmap），这个表记录了在方法区和栈中哪个位置存放了对象的引用。这样JVM扫枚举根节点时，只需要遍历Oopmap即可，大幅度降低了枚举的工作量。 在我看来，Oopmap有点像是一个对一个范围内所有引用对象的快照。

安全点
---

由于在程序执行过程中，对象的引用关系随时可能发生变化，因此Oopmap也会随时发生变化。JVM不会实时更新Oopmap，因为这样对性能的消耗会非常的大，因此JVM只选择在特点的位置更新Oopmap到最新状态，同时可能进行GC。这些位置就是安全点。 安全点的选择基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，如方法调用、循环跳转、异常跳转等。

安全区域
----

安全区域是指，在一段代码区域内，引用关系不会发生变化。相当于扩展的安全点。 根节点枚举是GC操作的必要步骤，同时进行根节点枚举必须在一个确保一致性的快照中，这就是GC需要停顿所有执行线程进行根节点枚举的原因。

垃圾收集器
=====

> !\[\](https://www.dokyme.cn/wp-content/uploads/2018/05/JavaGC.png) **按线程** 单线程：Serial、SerialOld 多线程：ParNew、Parallel Scavenge、Parallel Old、CMS、G1 **按适用代** 新生代: Serial、ParNew、Parallel Scavenge 老年代: SerialOld、CMS 、Parallel Old G1可以在新生代和老年代使用 **常见的组合** ParNew+CMS Parallel Scavenge+Parallel Old
> 
> 作者：王常贵 链接：https://www.zhihu.com/question/21535747/answer/18548071 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

CMS（Concurrent Mard Sweep）收集器
-----------------------------

![](https://oss.kherrisan.cn/Snipaste_2018-05-06_20-25-53.jpg) 四个步骤：

1.  初始标记（initial mark）：Stop The Word，并标记GC Root直接引用的对象，并做标记。这一步很快。
2.  并发标记（concurrent mark）：恢复执行线程，同时继续追踪各个引用路径，完成可达性分析。
3.  重新标记（remark）：Stop The Word，修正前一个阶段中标记产生变动的对象的标记记录。
4.  并发清除（concurrent sweep）：恢复执行线程，同时进行垃圾清除操作。

缺点： 1\. 对CPU资源敏感 2. 由于在并发清除阶段没有stop the world，因此无法应对“浮动垃圾”，即标记结束之后新产生的垃圾 3. 基于清除算法，会产生大量碎片

G1收集器
-----

四个步骤：

1.  初始标记（initial mark）：同CMS。
2.  并发标记（concurrent mark）：同CMS。
3.  最终标记（final mark）：同CMS的重新标记
4.  筛选回收（live data counting and evacuation）：对各个region的回收价值和所需时间（也就是性价比hhhhh）进行评估，排序，然后根据用户能够接受的GC停顿时间来指定回收计划。

G1和CMS最大的区别在于，G1将内存区域分为很多个region，对每个region的GC性价比进行评估，并维护一个GC优先列表。 找到了一个详细介绍G1垃圾回收过程的网站。

### 对于新生代对象

很简单，把Eden和Survivor中的对象做标记复制，复制到另一个Survivor或者提升到老年代中。需要Stop the World。 ![](https://oss.kherrisan.cn/Snipaste_2018-05-06_20-38-03.jpg)

### 对于老年代对象

首先，初始标记，标记所有GC Roots直接关联的对象。实际上这一步是在新生代GC的过程中顺带着做的。需要Stop the World。 ![](https://oss.kherrisan.cn/Snipaste_2018-05-06_20-50-38.jpg)

### G1的优势

2.  分代收集
3.  空间整合，不会存在碎片
4.  可预测的停顿时间

 

内存分配与回收
=======

其实内存分配的策略并不是一成不变的，不同的收集器组合可能会采用不同的内存分配规则。

对象优先在Eden分配
-----------

对象会优先在Eden区分配，如果Eden区空间不足，会触发一次minor GC。

大对象直接进入老年代
----------

因为新生代采用复制算法收集内存，如果新生代中有很多大对象，那复制就会很费时间，因此大对象直接放入老年代，使用标记清除或者标记整理算法更合适一些。

长期存活的对象进入老年代
------------

JVM记录每个新生代对象的年龄（age），每经过一次minor GC，age加一，当超过一定值的时候，就会被提升到老年代。

动态对象年龄判定
--------

如果survivor空间中某个年龄的所有对象的所占的大小大于survivor空间大小的一半，年龄大于等于该年龄的对象就可以提升到老年代中。全体晋升。

空间分配担保
------

在MinorGC时，会先检测老年代最大可用的连续空间是否大于新生代所有对象总空间。如果不成立，检查历次晋升到老年代对象的平均大小是否大于老年代最大可用连续空间，如果小于，则进行一次MinorGC，如果大于，进行FullGC。 担保失败后只能进行FullGC，回收老年代空间。