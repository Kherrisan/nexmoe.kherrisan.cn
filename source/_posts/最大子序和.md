---
title: 53.最大子序和
tags:
  - Leetcode
  - 算法
math: true
abbrlink: 396fd427
date: 2020-05-03 12:26:46
---

给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

> 输入: [-2,1,-3,4,-1,2,1,-5,4]
> 输出: 6
> 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。

<!-- more -->

## 滑动窗口

乍一看，子序和是连续的，那么就会很自然地想到滑动窗口的形式：维护两个指针，一左一右。

问题在于左右指针何时移动。看右指针的话，可能会碰到正数或者负数，如果右指针向右移动一位之后是正数，那这个区间内的子序和肯定会变大；如果移动之后是负数，那子序和就会变小，看似右指针此时就不需要移动了。

但问题在于你不知道这个负数之后是不是还跟着一个绝对值更大的正数，如果是的话，那这个负数就应该被划归到子序区间内。

左指针从左向右移动，如果指向负数，那就向右移动一格，如果是正数，看似这个正数能够让子序和更大，但同样的，无法确定在这个正数之后是否存在一个绝对值比他更大的负数，那么左指针就需要向右移动两格。

这样一种对未来遇到的元素的未知，导致无法判断是否要移动指针。如果使用暴力解法，枚举每个左指针和右指针位置的组合，那么时间复杂度为：$O(n^2)$。

## 动态规划

### 优化的移动规则

**实际上动态规划也是从另一个角度理清左右指针的移动关系。既然无法预知接下来元素的正负，那就从当前的序列和的正负入手。**

假设现在有一个区间以及左右指针。接下来要决定如何移动左右指针。

1. 如果这个区间所包含的子序和小于 0，那么说明这个子序列肯定不是最终结果，因为这个子序列后面紧跟着的一个数，无论他是正数还是负数，子序列包含了这个数之后的和都会比这个数小。这时左右指针可以直接指向下一个数，区间的宽度变为 1。
2. 子序列和大于 0。这时可以移动右指针，但为了能够得到所有情况中的最大子序和，需要把子序和记录下来。这时左指针不动。

总得来说，左指针跳着走，右指针一格一格走。那为什么左指针不需要一格一格走呢？

考察这个数组：

$$[1, -2, 3, -5, 7, 8, -2]$$

左指针指向 1，右指针指向 3，那么此时就是在**滑动窗口**中讨论到的：左指针要向右移动，并且 -2 的绝对值比 1 大，因此需要把左指针向右移动两格到 3。但是根据本节上面刚刚给出的移动规则，是不可能存在这样的情况的，因为$[1, -2]$的和小于 0，所以下一步左右指针肯定直接指向 3 了。

也就是说左指针不需要一格一格走，可以跳着走。

在实际编码的过程中，不需要一板一眼地定义两个变量(left、right)，来标识左右指针的位置。题目的答案并不关系最小子序和的位置，而只关心**子序和的值**。所以定义一个变量 sum 来标识当前的最小子序和。把上面的**判断正负**的思想表示成代码：

```java
if (num > 0) {
    sum += num;
} else {
    sum = num;
}
```

可以优化成 ``sum = Math.max(num, sum + num);``

### 相同形式较小规模的子问题

定义 $f(i)$ 表示已位置 i 结尾的子序和，那么满足：

$$
f(i)=max\\{f(i-1)+a[i],a[i]\\}
$$

由此可以得到一个$f(i)$的表，要从表中找到最大值。由于$f(i)$在计算时只和前面的 i 有关，因此不需要真正开辟一个数组来存放每个$f(i)$，而是只要记录当前的最大$f(i)$，如果有更大的，就把之前找到的值抛弃掉。

在一个 for 循环中干两件事：

1. 更新以 i 位置结尾的最大子序和，即计算 $f(i)$
2. 更新 $f(0)$ 到 $f(i)$ 范围内的所有子序和的最大值。

代码如下：

```java
class Solution {
    public int maxSubArray(int[] nums) {
        if(nums.length==0){
            return 0;
        }
        int res=nums[0];
        int sum=0;
        for(int n:nums){
            sum=Math.max(sum+n,n);
            res=Math.max(res,sum);
        }
        return res;
    }
}
```

## 分治