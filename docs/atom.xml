<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kherrisan</title>
  <icon>http://www.kherrisan.cn/icon.png</icon>
  <subtitle> 科瑞杉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.kherrisan.cn/"/>
  <updated>2020-05-03T08:41:45.630Z</updated>
  <id>http://www.kherrisan.cn/</id>
  
  <author>
    <name>Kherrisan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>53.最大子序和</title>
    <link href="http://www.kherrisan.cn/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/"/>
    <id>http://www.kherrisan.cn/2020/05/03/%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</id>
    <published>2020-05-03T12:26:46.000Z</published>
    <updated>2020-05-03T08:41:45.630Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><blockquote><p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p></blockquote><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><p>乍一看，子序和是连续的，那么就会很自然地想到滑动窗口的形式：维护两个指针，一左一右。</p><p>问题在于左右指针何时移动。看右指针的话，可能会碰到正数或者负数，如果右指针向右移动一位之后是正数，那这个区间内的子序和肯定会变大；如果移动之后是负数，那子序和就会变小，看似右指针此时就不需要移动了。</p><p>但问题在于你不知道这个负数之后是不是还跟着一个绝对值更大的正数，如果是的话，那这个负数就应该被划归到子序区间内。</p><p>左指针从左向右移动，如果指向负数，那就向右移动一格，如果是正数，看似这个正数能够让子序和更大，但同样的，无法确定在这个正数之后是否存在一个绝对值比他更大的负数，那么左指针就需要向右移动两格。</p><p>这样一种对未来遇到的元素的未知，导致无法判断是否要移动指针。如果使用暴力解法，枚举每个左指针和右指针位置的组合，那么时间复杂度为：$O(n^2)$。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="优化的移动规则"><a href="#优化的移动规则" class="headerlink" title="优化的移动规则"></a>优化的移动规则</h3><p><strong>实际上动态规划也是从另一个角度理清左右指针的移动关系。既然无法预知接下来元素的正负，那就从当前的序列和的正负入手。</strong></p><p>假设现在有一个区间以及左右指针。接下来要决定如何移动左右指针。</p><ol><li>如果这个区间所包含的子序和小于 0，那么说明这个子序列肯定不是最终结果，因为这个子序列后面紧跟着的一个数，无论他是正数还是负数，子序列包含了这个数之后的和都会比这个数小。这时左右指针可以直接指向下一个数，区间的宽度变为 1。</li><li>子序列和大于 0。这时可以移动右指针，但为了能够得到所有情况中的最大子序和，需要把子序和记录下来。这时左指针不动。</li></ol><p>总得来说，左指针跳着走，右指针一格一格走。那为什么左指针不需要一格一格走呢？</p><p>考察这个数组：</p><p>$$[1, -2, 3, -5, 7, 8, -2]$$</p><p>左指针指向 1，右指针指向 3，那么此时就是在<strong>滑动窗口</strong>中讨论到的：左指针要向右移动，并且 -2 的绝对值比 1 大，因此需要把左指针向右移动两格到 3。但是根据本节上面刚刚给出的移动规则，是不可能存在这样的情况的，因为$[1, -2]$的和小于 0，所以下一步左右指针肯定直接指向 3 了。</p><p>也就是说左指针不需要一格一格走，可以跳着走。</p><p>在实际编码的过程中，不需要一板一眼地定义两个变量(left、right)，来标识左右指针的位置。题目的答案并不关系最小子序和的位置，而只关心<strong>子序和的值</strong>。所以定义一个变量 sum 来标识当前的最小子序和。把上面的<strong>判断正负</strong>的思想表示成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (num > <span class="number">0</span>) {</span><br><span class="line">    sum += num;</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    sum = num;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>可以优化成 <code>sum = Math.max(num, sum + num);</code></p><h3 id="相同形式较小规模的子问题"><a href="#相同形式较小规模的子问题" class="headerlink" title="相同形式较小规模的子问题"></a>相同形式较小规模的子问题</h3><p>定义 $f(i)$ 表示已位置 i 结尾的子序和，那么满足：</p><p>$$<br>f(i)=max{f(i-1)+a[i],a[i]}<br>$$</p><p>由此可以得到一个$f(i)$的表，要从表中找到最大值。由于$f(i)$在计算时只和前面的 i 有关，因此不需要真正开辟一个数组来存放每个$f(i)$，而是只要记录当前的最大$f(i)$，如果有更大的，就把之前找到的值抛弃掉。</p><p>在一个 for 循环中干两件事：</p><ol><li>更新以 i 位置结尾的最大子序和，即计算 $f(i)$</li><li>更新 $f(0)$ 到 $f(i)$ 范围内的所有子序和的最大值。</li></ol><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>{</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>){</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n:nums){</span><br><span class="line">            sum=Math.max(sum+n,n);</span><br><span class="line">            res=Math.max(res,sum);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><h2 id="分治"><a href="#分治" class="headerlink" title="分治"></a>分治</h2>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4]&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2,1]
        
      
    
    </summary>
    
    
    
      <category term="Leetcode" scheme="http://www.kherrisan.cn/tags/Leetcode/"/>
    
      <category term="算法" scheme="http://www.kherrisan.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我理想的文档管理模式</title>
    <link href="http://www.kherrisan.cn/2020/04/22/%E6%88%91%E7%90%86%E6%83%B3%E7%9A%84%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    <id>http://www.kherrisan.cn/2020/04/22/%E6%88%91%E7%90%86%E6%83%B3%E7%9A%84%E6%96%87%E6%A1%A3%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-22T21:23:16.000Z</published>
    <updated>2020-05-03T08:41:45.630Z</updated>
    
    <content type="html"><![CDATA[<h1 id="我理想的文档管理模式"><a href="#我理想的文档管理模式" class="headerlink" title="我理想的文档管理模式"></a>我理想的文档管理模式</h1><h2 id="印象笔记"><a href="#印象笔记" class="headerlink" title="印象笔记"></a>印象笔记</h2><p><img src="https://oss.kherrisan.cn/20200422220756.png" alt></p><p>在我把电脑换成了 Macbook Pro 之后，我开始尝试用<a href>印象笔记</a>来进行文档管理。现在，我的印象笔记不仅用来存放我平时的所有正式和非正式的书写，包括零碎的草稿和阅读笔记，还承载了<strong>稍后阅读、文件归档（证书、发票、说明书）</strong>这两大功能。</p><ol><li>通过 <strong>ios 的分享、MacOS Safari 的剪藏插件</strong>，可以将网页（准确地说是 URL）的内容存放在印象笔记中，虽说有时剪藏得到的网页内容并不完整，但也算可用。</li><li>得益于印象笔记优秀的<strong>中文全文搜索功能</strong>，那些需要长期保存的文件也被我放在了印象笔记中，方便随手检索。而 Alfred 的<a href>印象笔记 Workflow</a>，更是让文档的检索更加快捷方便。</li></ol><p>但是我也发现了一些问题，例如</p><ol><li>印象笔记的文档和 MacOS 的本地文件（先不论是不是 iCloud）的管辖范围在某些程度上会产生重合。</li><li>印象笔记虽然在笔记领域还是比较成熟的，但是 MacOS 端的客户端体验并不完美，有一些很气的小问题：<ol><li>在某个笔记包含较多的图片时，上下滑动不平滑，一卡一卡。</li><li>对 Markdown 格式支持不完整。</li></ol></li><li>要钱（虽说穷是我的问题）。</li></ol><h2 id="Devonthink"><a href="#Devonthink" class="headerlink" title="Devonthink"></a>Devonthink</h2><p><img src="https://oss.kherrisan.cn/20200422220915.png" alt></p><p>在少数派的文章中了解到了 <a href>Devonthink</a> 这款软件。Devonthink 是个非常专业的文档管理工具，他本身的存储从文件系统的角度看是和 MacOS 的图库一样的，有一个专门的数据库文件，需要把文件加入到 Devonthink 数据库里进行整理，但 Devonthink 支持引用而不拷贝文件，这样就不会出现两个副本的问题。Devonthink 不仅是从文件的归类整理、检索来说都是非常专业的，唯一的问题在于这个软件<strong>太贵了</strong>！！！</p><h2 id="Onedrive-amp-amp-VSCode"><a href="#Onedrive-amp-amp-VSCode" class="headerlink" title="Onedrive && VSCode"></a>Onedrive && VSCode</h2><p>我最近挖掘了一种新的文档管理模式。</p><ul><li>使用 Onedrive 进行多设备同步。Onedrive 的云同步和版本管理还是很可靠的。</li><li>使用 VScode 进行 Markdown 的写作。</li></ul><p>在 iPhone 和 iPad 上都有 Onedrive 的客户端，可以直接搜索、阅读 pdf、word 等格式文件，唯一美中不足的是 iPad 上的 Onedrive 在打开 Markdown 文件时会出现乱码，导致该文件上的全文搜索索引失效，因此搜素 Markdown 文件中的内容算是废了。</p><p>Onedrive 对于 Office 套件的文件格式的搜索倒是支持地很不错。</p><h2 id="理想的文件管理"><a href="#理想的文件管理" class="headerlink" title="理想的文件管理"></a>理想的文件管理</h2><p>我理想的文件管理模式有以下的特征：</p><ol><li>有快捷的全文检索，尤其是要对中文有良好的支持。对于扫描版的 PDF 要能够进行 OCR 扫描后进行检索，对于可编辑的 PDF 也要能够进行检索。</li><li>多终端同步，最好能够跨平台，因为未来我还是有可能用到 Windows 生态的。如果不能跨平台的话最好有 WEB 端。</li><li>优秀的 Markdown 撰写体验，对于其他的文档格式（word、excel、pdf）要能够支持阅读。</li></ol><p>目前还未找到完全符合我要求的文档管理软件，目测需要我自己开发。等我有空了就自己去写一个~</p><h2 id="如果需要我来开发这个软件的话"><a href="#如果需要我来开发这个软件的话" class="headerlink" title="如果需要我来开发这个软件的话"></a>如果需要我来开发这个软件的话</h2><p>APP 的形式和大多数的笔记 APP 类似。</p><ol><li>多格式阅读。</li><li>Markdown 格式写作。</li><li>借助于 Onedrive（或者 Dropbox、iCloud）的的跨平台同步。</li><li>全文检索。</li><li>其他高级的文档组织功能，例如标签、关联等。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h1 id=&quot;我理想的文档管理模式&quot;&gt;&lt;a href=&quot;#我理想的文档管理模式&quot; class=&quot;headerlink&quot; title=&quot;我理想的文档管理模式&quot;&gt;&lt;/a&gt;我理想的文档管理模式&lt;/h1&gt;&lt;h2 id=&quot;印象笔记&quot;&gt;&lt;a href=&quot;#印象笔记&quot;
        
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>新的主题</title>
    <link href="http://www.kherrisan.cn/2020/04/10/%E6%96%B0%E7%9A%84%E4%B8%BB%E9%A2%98/"/>
    <id>http://www.kherrisan.cn/2020/04/10/%E6%96%B0%E7%9A%84%E4%B8%BB%E9%A2%98/</id>
    <published>2020-04-10T20:06:23.000Z</published>
    <updated>2020-05-03T08:41:45.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>之前一直使用 Hexo 的 next 主题来呈现博客，最近觉得 next 太素了，想换一个花哨一些的~</p><h2 id="Nexmoe"><a href="#Nexmoe" class="headerlink" title="Nexmoe"></a>Nexmoe</h2><p>这个主题还是我在 Github 首页被推荐到的，看来 Github 的推荐算法越来越智能了，连博客主题的个人喜好都能作为推荐的标准了（开个玩笑）。</p><h2 id="额外的工作"><a href="#额外的工作" class="headerlink" title="额外的工作"></a>额外的工作</h2><h3 id="博文封面"><a href="#博文封面" class="headerlink" title="博文封面"></a>博文封面</h3><p>Nexmoe 支持为每篇文章配置一个漂漂亮亮的封面图，操作方法是在文章 md 文件的头部添加下面几行代码，分别是图片的 http 地址、长度和宽度。据作者说，之所要要显式地声明文件长宽，是为了消除图片的抖动。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">cover:</span> <span class="string">https://i.loli.net/2019/07/21/5d33d5dc1531213134.png</span></span><br><span class="line"><span class="attr">coverWidth:</span> <span class="number">1200</span></span><br><span class="line"><span class="attr">coverHeight:</span> <span class="number">750</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="社交链接"><a href="#社交链接" class="headerlink" title="社交链接"></a>社交链接</h3><p>作者的博客首页摆上了一堆社交网站的 Logo，特别可爱。</p><p><img src="https://oss.kherrisan.cn/20200410201550.png" alt></p><p>在主题的 _config.yml 文件中，可以添加社交网站的 Logo 和个人链接。我暂时搞了四个。</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">social:</span><br><span class="line">  哔哩哔哩:</span><br><span class="line">    - https:<span class="comment">//space.bilibili.com/13288240</span></span><br><span class="line">    - icon-bilibili</span><br><span class="line">    - rgb(<span class="number">231</span>, <span class="number">106</span>, <span class="number">141</span>)</span><br><span class="line">    - rgba(<span class="number">231</span>, <span class="number">106</span>, <span class="number">141</span>, <span class="number">.15</span>)</span><br><span class="line">  GitHub:</span><br><span class="line">    - https:<span class="comment">//github.com/kherrisan/</span></span><br><span class="line">    - icon-github</span><br><span class="line">    - rgb(<span class="number">25</span>, <span class="number">23</span>, <span class="number">23</span>)</span><br><span class="line">    - rgba(<span class="number">25</span>, <span class="number">23</span>, <span class="number">23</span>, <span class="number">.15</span>)</span><br><span class="line">  Telegram:</span><br><span class="line">    - https:<span class="comment">//github.com/kherrisan/</span></span><br><span class="line">    - icon-telegram</span><br><span class="line">    - rgb(<span class="number">39</span>,<span class="number">167</span>,<span class="number">229</span>)</span><br><span class="line">    - rgba(<span class="number">39</span>,<span class="number">167</span>,<span class="number">229</span>,<span class="number">.1</span>)</span><br><span class="line">  知乎:</span><br><span class="line">    - https:<span class="comment">//www.zhihu.com/people/smalldk</span></span><br><span class="line">    - icon-zhihu</span><br><span class="line">    - rgb(<span class="number">00</span>,<span class="number">132</span>, <span class="number">256</span>)</span><br><span class="line">    - rgba(<span class="number">00</span>, <span class="number">132</span>, <span class="number">256</span>, <span class="number">.15</span>)</span><br></pre></td></tr></table></figure><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>Mexmoe 自带了代码高亮，需要把 Hexo 默认的代码高亮功能关掉，来避免功能冲突。</p><h3 id="评论系统"><a href="#评论系统" class="headerlink" title="评论系统"></a>评论系统</h3><p>我使用的是 Gittalk。先简单描述一下 Gitalk 的原理：</p><ol><li>博客的网页中包含 Gitalk 的 js 脚本，在打开文章页的时候，浏览器会加载 js 脚本的内容。</li><li>js 脚本会去请求 Github 的一个接口，通过这个接口去查询指定仓库的 issues，这个仓库就是在 <strong>_config.yml</strong> 中的 <strong>repo</strong>，repo 不是存放博客内容的仓库名，而是指存放评论的仓库名，当然很多人把评论直接放在博客内容的仓库里，所以 repo 就是 xxx.github.io 这个格式。使用 key 和 secret 来对接口进行鉴权。我另外新建了一个叫 gitalk 的仓库，故 repo 就只要写 gitalk 就行了。</li><li>Github 的服务器接口收到了查询 issues 的相关请求，同时会检查请求来自的 Host 是不是你博客真正部署所在的网址，对于大多数人是 xxx.github.io，如果使用自定义域名，也可以是 <a href="http://www.xxx.com">www.xxx.com</a> 这样。至于到底是什么样，是由用户在 Github - OAuth App 中的 <strong>Authorization callback URL</strong> 指定的。如果你在本地调试，那就应该写为 localhost:4000。当然它也会验证 key 和 secret 是否匹配。至于 <strong>Homepage URL</strong> 我还不知道有什么用，貌似可以随便写。</li><li>Github 的接口返回 issues 给浏览器，浏览器呈现评论列表。</li></ol><p>我的 gitalk 是这么配置的：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">gitalk:</span></span><br><span class="line"><span class="symbol">  admin:</span> kherrisan</span><br><span class="line"><span class="symbol">  owner:</span> kherrisan</span><br><span class="line"><span class="symbol">  repo:</span> gitalk</span><br><span class="line"><span class="symbol">  clientID:</span> cef6ec0ef4709xxxxxx</span><br><span class="line"><span class="symbol">  clientSecret:</span> c184430c4d516f1f71911b1ba06947815fxxxxxx</span><br></pre></td></tr></table></figure><p>既然评论列表是浏览器直接从 Github 请求得到的，这就会产生一个问题：Github 服务器在国外，国内的用户在查看评论列表时可能会加载较长的时间。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="网页代码压缩"><a href="#网页代码压缩" class="headerlink" title="网页代码压缩"></a>网页代码压缩</h3><p>通过 gulp 来压缩 html、css、js 的代码，压缩完了之后的代码，在 chrome 的调试工具中，会变成特别长的一行~</p><h3 id="css-js内联"><a href="#css-js内联" class="headerlink" title="css/js内联"></a>css/js内联</h3><p>使用 <a href="https://github.com/JamesPan/hexo-filter-asset-inline">hexo-filter-asset-inline</a>。</p><p>先 npm 下载这个库，然后在每个需要内联的 js、css 文件地址后面加上 <code>?__inline=true</code>。由于 hexo 没有一个统一的地方存放 css、js 的地址，而各个主题引用外部 css、js 的地方又各有不同，因此只能在编辑器里面搜索，然后一处处手动添加了。</p><p>全部地址修改完成后，打开网页应只需要加载 html 文件以及少数一个图片文件。</p><p><img src="https://oss.kherrisan.cn/20200410221659.png" alt></p><h3 id="全站加速（氪金上云）"><a href="#全站加速（氪金上云）" class="headerlink" title="全站加速（氪金上云）"></a>全站加速（氪金上云）</h3><p>所有图片放到阿里云 OSS 上去，并且使用全站加速（实际上就是 CDN）来加速对 <a href="https://www.kherrisan.cn">https://www.kherrisan.cn</a> 这个域名下所有资源的访问。</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>我想实现的效果是，我在本地完成撰写后，只需要提交 source 代码，然后 Github 的 Action 会自动帮我完成压缩、编译、部署的工作。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://docs.nexmoe.com/hexo/#遇到问题怎么办？">Nexmoe 文档</a><br><a href="https://nexmoe.com/661812793.html#资源合并">博客，我优化了什么？</a><br><a href="https://todebug.com/use-gulp-with-hexo/">hexo优化之——使用gulp压缩资源</a></p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;之前一直使用 Hexo 的 next 主题来呈现博客，最近觉得 next 太素了，想换一个花哨一些的~&lt;/p&gt;
&lt;h2
        
      
    
    </summary>
    
    
    
      <category term="博客" scheme="http://www.kherrisan.cn/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="主题" scheme="http://www.kherrisan.cn/tags/%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>2019年7月6日周记</title>
    <link href="http://www.kherrisan.cn/2019/07/06/2019%E5%B9%B47%E6%9C%886%E6%97%A5%E5%91%A8%E8%AE%B0/"/>
    <id>http://www.kherrisan.cn/2019/07/06/2019%E5%B9%B47%E6%9C%886%E6%97%A5%E5%91%A8%E8%AE%B0/</id>
    <published>2019-07-06T19:56:39.000Z</published>
    <updated>2020-05-03T08:41:45.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019年6月31日-2019年7月6日"><a href="#2019年6月31日-2019年7月6日" class="headerlink" title="2019年6月31日-2019年7月6日"></a>2019年6月31日-2019年7月6日</h2><p>离校了，宿舍里的东西全都搬到了家里，也都收拾好了。6月26日开始的为期三天的招生工作也宣告结束，不知道未来还有没有机会和计软的招生老师们一起去一中玩（zhuang）耍（bi）。</p><a id="more"></a><p>本以为到家了之后能够很快进入复习状态的，却没有料到人的惰性比我想象中的更加难以克服。常常是早上睡到89点钟起床，吃完午饭一不小心就在床上躺一整个下午，为了凑个整把晚上的时间也浪费掉了。晚上睡觉也睡得很晚，基本上天天都要熬到后半夜。</p><p>我理想的复习状态类似于人们常说的“<strong>吃了枪药，打了鸡血</strong>”那样的精神状态，但现在的状态却可以称作为“<strong>吸了大麻</strong>”。究其原因，还是因为觉悟不够，没有认清情况。我认为我目前的复习进度不算快也不算慢，属于比较稳健但又不是很积极的那一类。目前还在全力复习数学，刚刚完成高数知识点和习题的第一轮复习，除了数学之外，每天背单词，每天练字。我打算在数学第一轮结束时开始其他科目的同步复习，我认为这样安排对于我而言应该是合适的。进度是自己的，没有必要和别人去比，现在的问题是调整心态，端正态度，多给自己打一点鸡血，同时主动尝试自我调节的方式。</p><p>此时窗外忽然风雨大作，似乎我网上买的50一双的鞋套明天终于能有<strong>用武之地</strong>了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2019年6月31日-2019年7月6日&quot;&gt;&lt;a href=&quot;#2019年6月31日-2019年7月6日&quot; class=&quot;headerlink&quot; title=&quot;2019年6月31日-2019年7月6日&quot;&gt;&lt;/a&gt;2019年6月31日-2019年7月6日&lt;/h2&gt;&lt;p&gt;离校了，宿舍里的东西全都搬到了家里，也都收拾好了。6月26日开始的为期三天的招生工作也宣告结束，不知道未来还有没有机会和计软的招生老师们一起去一中玩（zhuang）耍（bi）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://www.kherrisan.cn/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
      <category term="考研" scheme="http://www.kherrisan.cn/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="复习" scheme="http://www.kherrisan.cn/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="记录" scheme="http://www.kherrisan.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="日常" scheme="http://www.kherrisan.cn/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>2019年6月消费情况总结及7月预算</title>
    <link href="http://www.kherrisan.cn/2019/07/01/2019%E5%B9%B46%E6%9C%88%E6%B6%88%E8%B4%B9%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93%E5%8F%8A7%E6%9C%88%E9%A2%84%E7%AE%97/"/>
    <id>http://www.kherrisan.cn/2019/07/01/2019%E5%B9%B46%E6%9C%88%E6%B6%88%E8%B4%B9%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93%E5%8F%8A7%E6%9C%88%E9%A2%84%E7%AE%97/</id>
    <published>2019-07-01T09:34:36.000Z</published>
    <updated>2020-05-03T08:41:45.622Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h2 id="6月消费总结"><a href="#6月消费总结" class="headerlink" title="6月消费总结"></a>6月消费总结</h2><p>6月是我呆在东大的最后一个月，在这一个月中，有正常的消费（饮食、起居），也有满足特殊要求的（毕业相关事件）。</p><ol><li>餐饮占消费支出大头。</li><li>买了个键盘，花了不少钱。</li><li>其他方面的消费分布较为均匀。</li></ol><p>本来我以为消费支出还挺多的，实际上没有5月份多，各方面的支出水平都在预料的范围内。</p><h2 id="7月消费预算"><a href="#7月消费预算" class="headerlink" title="7月消费预算"></a>7月消费预算</h2><p>7月份在家，餐饮方面的支出可以在很大程度上缩减。另其他方面支出除周期性支出外都要缩减（专心复习）。</p><table><thead><tr><th>类别</th><th>预算</th><th></th></tr></thead><tbody><tr><td>饮食</td><td>4 x 50（零食）= 200</td><td></td></tr><tr><td>云服务</td><td>26</td><td></td></tr><tr><td>订阅</td><td>16（滴答清单）+ 10（icloud）+ 12（潮汐）+10（bear）=  48</td><td></td></tr><tr><td>总计</td><td>274</td><td></td></tr></tbody></table><p>这个月的消费完全可以通过转嫁到家人身上的方式来减少数额，虽然这样想好想不太好，但这里只从我自己的资产和消费角度考虑。通过他人代自己消费也应算作一种方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h2 id=&quot;6月消费总结&quot;&gt;&lt;a href=&quot;#6月消费总结&quot; class=&quot;headerlink&quot;
        
      
    
    </summary>
    
    
      <category term="消费分析" scheme="http://www.kherrisan.cn/categories/%E6%B6%88%E8%B4%B9%E5%88%86%E6%9E%90/"/>
    
    
      <category term="消费" scheme="http://www.kherrisan.cn/tags/%E6%B6%88%E8%B4%B9/"/>
    
      <category term="月记" scheme="http://www.kherrisan.cn/tags/%E6%9C%88%E8%AE%B0/"/>
    
      <category term="预算" scheme="http://www.kherrisan.cn/tags/%E9%A2%84%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>2019年5月消费情况总结及6月预算</title>
    <link href="http://www.kherrisan.cn/2019/06/02/2019%E5%B9%B45%E6%9C%88%E6%B6%88%E8%B4%B9%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93%E5%8F%8A6%E6%9C%88%E9%A2%84%E7%AE%97/"/>
    <id>http://www.kherrisan.cn/2019/06/02/2019%E5%B9%B45%E6%9C%88%E6%B6%88%E8%B4%B9%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93%E5%8F%8A6%E6%9C%88%E9%A2%84%E7%AE%97/</id>
    <published>2019-06-02T18:03:51.000Z</published>
    <updated>2020-05-03T08:41:45.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="5月消费总结"><a href="#5月消费总结" class="headerlink" title="5月消费总结"></a>5月消费总结</h2><p>我在五月的消费非常地不按照常理出牌，收入方面：</p><ol><li>在KXD的四月的实习工资到账，900。</li><li>毕业生退学费，1900.</li><li>把iPad Pro 10.5在闲鱼上卖掉了，3000.</li></ol><a id="more"></a><p>乍一看感觉收入还挺多的，但收入多导致自己没有给自己的支持限制施加足够的压力和约束力，导致消费也不少。几个大头消费有：</p><ol><li>给MacBook Pro补了一个Apple Care Protection Plan，1800左右。这个消费如果分摊到未来两年的话还是很划算的，相当于给电脑买了一个保险。</li><li>入坑当红手游明日方舟，氪了不少钱，大概1200，这个氪钱就完全是“<strong>瞎花钱</strong>”了哈哈哈。</li></ol><p>五月消费数据如下图。</p><p><img src="http://ipic.dokyme.cn/260676f21af274d1f380452e2dfd5939.png" alt="2019-06-02-18-16-55"></p><p>此外，我爸给我转了1000元委托我管理BTC交易，虽然名义上是他的钱，但我感觉他一时半会儿不会找我要回去（他要怎么开口？），想在5.14生日那天问我妈要两千结果没有开口。</p><h2 id="6月消费预算"><a href="#6月消费预算" class="headerlink" title="6月消费预算"></a>6月消费预算</h2><p>针对5月的几个消费大头，以及消费效率较低的类别，给出下一个月的预算如下：</p><table><thead><tr><th>类别</th><th>预算</th><th></th></tr></thead><tbody><tr><td>饮食</td><td>27 x 30（早中晚饭）+ 15 x 10（水果）+ 4 x 30（零食）= 1080</td><td></td></tr><tr><td>云服务</td><td>26 + 20 = 46</td><td></td></tr><tr><td>订阅</td><td>16（滴答清单）+ 10（icloud）+ 12（潮汐）=  32</td><td></td></tr><tr><td>总计</td><td>1148</td><td></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;5月消费总结&quot;&gt;&lt;a href=&quot;#5月消费总结&quot; class=&quot;headerlink&quot; title=&quot;5月消费总结&quot;&gt;&lt;/a&gt;5月消费总结&lt;/h2&gt;&lt;p&gt;我在五月的消费非常地不按照常理出牌，收入方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在KXD的四月的实习工资到账，900。&lt;/li&gt;
&lt;li&gt;毕业生退学费，1900.&lt;/li&gt;
&lt;li&gt;把iPad Pro 10.5在闲鱼上卖掉了，3000.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="消费分析" scheme="http://www.kherrisan.cn/categories/%E6%B6%88%E8%B4%B9%E5%88%86%E6%9E%90/"/>
    
    
      <category term="消费" scheme="http://www.kherrisan.cn/tags/%E6%B6%88%E8%B4%B9/"/>
    
      <category term="月记" scheme="http://www.kherrisan.cn/tags/%E6%9C%88%E8%AE%B0/"/>
    
      <category term="预算" scheme="http://www.kherrisan.cn/tags/%E9%A2%84%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>2019年4月消费情况总结及5月预算</title>
    <link href="http://www.kherrisan.cn/2019/04/29/2019%E5%B9%B44%E6%9C%88%E6%B6%88%E8%B4%B9%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93%E5%8F%8A5%E6%9C%88%E9%A2%84%E7%AE%97/"/>
    <id>http://www.kherrisan.cn/2019/04/29/2019%E5%B9%B44%E6%9C%88%E6%B6%88%E8%B4%B9%E6%83%85%E5%86%B5%E6%80%BB%E7%BB%93%E5%8F%8A5%E6%9C%88%E9%A2%84%E7%AE%97/</id>
    <published>2019-04-29T20:01:13.000Z</published>
    <updated>2020-05-03T08:41:45.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>为了能够及时对”不堪回首“的消费记录进行分析和总结，并对下一个月的消费做出有效可行的预算，在此为消费单独开辟一个栏目。</p><a id="more"></a><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>覆盖时间为当月1日到当月最后一日。</p><h2 id="4月消费总结"><a href="#4月消费总结" class="headerlink" title="4月消费总结"></a>4月消费总结</h2><p>4月是完整实习的最后一个月，也是拿完整工资的最后一个月，收入还比较充裕。</p><p><img src="http://ipic.dokyme.cn/ac904db0a96f4a44cbbda178d83749cb.png" alt="2019-04-29-21-14-45"></p><p>本月支出1900，其中在餐饮上花费了接近1000，应该是<strong>外卖+水果</strong>消费了大部分额外的开支。假设每天花10元买水果，那么一个月就要多花近300元，这样虽然保证了充足的维生素摄入，但是还是有点吃不起的感觉。因为在宿舍带了好几天，那几天平均一天一顿外卖，因此在昂贵的外卖也拉高了原本在低水平食堂就能够满足的开销。</p><p>订阅（即购买App和App内会员）上所花的钱也过多，其中quizlet（一个被单词的App）买了却没有用。无效的订阅太多。</p><p>云服务的花费主体应该只有阿里云的ECS（HK），ECS的钱主要分为基础配置费和流量费。基础配置费26元（下一个月开始是13元，找到了拼车的小伙伴），流量费1元/G，下一个月应该将流量控制在20G以下。</p><h2 id="5月消费预算"><a href="#5月消费预算" class="headerlink" title="5月消费预算"></a>5月消费预算</h2><p>针对4月的几个消费大头，以及消费效率较低的类别，给出下一个月的预算如下：</p><table><thead><tr><th>类别</th><th>预算</th><th></th></tr></thead><tbody><tr><td>饮食</td><td>27 * 25（早中晚饭）+ 15 * 10（水果）+4 * 15（零食）= 885</td><td></td></tr><tr><td>云服务</td><td>13 + 20 = 33</td><td></td></tr><tr><td>订阅</td><td>16（滴答清单）+ 10（icloud）+ 12（潮汐）=  32</td><td></td></tr><tr><td>总计</td><td>950</td><td></td></tr></tbody></table><p>（我才发现有鱼记账没有预算的功能，这点没有moneywiz做得好）</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;为了能够及时对”不堪回首“的消费记录进行分析和总结，并对下一个月的消费做出有效可行的预算，在此为消费单独开辟一个栏目。&lt;/p&gt;
    
    </summary>
    
    
      <category term="消费分析" scheme="http://www.kherrisan.cn/categories/%E6%B6%88%E8%B4%B9%E5%88%86%E6%9E%90/"/>
    
    
      <category term="消费" scheme="http://www.kherrisan.cn/tags/%E6%B6%88%E8%B4%B9/"/>
    
      <category term="月记" scheme="http://www.kherrisan.cn/tags/%E6%9C%88%E8%AE%B0/"/>
    
      <category term="预算" scheme="http://www.kherrisan.cn/tags/%E9%A2%84%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>2019年4月29日周记</title>
    <link href="http://www.kherrisan.cn/2019/04/29/2019%E5%B9%B44%E6%9C%8829%E6%97%A5%E5%91%A8%E8%AE%B0/"/>
    <id>http://www.kherrisan.cn/2019/04/29/2019%E5%B9%B44%E6%9C%8829%E6%97%A5%E5%91%A8%E8%AE%B0/</id>
    <published>2019-04-29T19:56:39.000Z</published>
    <updated>2020-05-03T08:41:45.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019年4月22日-2019年4月28日"><a href="#2019年4月22日-2019年4月28日" class="headerlink" title="2019年4月22日-2019年4月28日"></a>2019年4月22日-2019年4月28日</h2><p>本周是开始考研复习的第三周，实际上只复习了一天。在周一经过小伙伴提醒五一之后要交论文初稿，因此周一之后的所有时间都用来写论文了。但是论文进度比想象的慢，写作效率不高，可以形容为”<strong>以写论文的名义划水</strong>“。</p><a id="more"></a><p>毕业论文中已经完成的部分质量尚可，但是进度缓慢，效率低下。本质的原因还是<strong>自制力差</strong>。</p><p>在B站上花的时间太多，主要观看的视频包括但不限于新番吐槽、星际2比赛，把b站动态当成朋友圈刷。自我感觉已经形成了<strong>Bilibili瘾</strong>。</p><p>实际上，如果能够把正事做完的话，是可以适当地在b站休闲一下的。但现实的情况是，因为在b站上”浪费时间“导致正事没有按计划完成。</p><p>马上五一假期要到了，预计4月30日完成论文初稿。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;2019年4月22日-2019年4月28日&quot;&gt;&lt;a href=&quot;#2019年4月22日-2019年4月28日&quot; class=&quot;headerlink&quot; title=&quot;2019年4月22日-2019年4月28日&quot;&gt;&lt;/a&gt;2019年4月22日-2019年4月28日&lt;/h2&gt;&lt;p&gt;本周是开始考研复习的第三周，实际上只复习了一天。在周一经过小伙伴提醒五一之后要交论文初稿，因此周一之后的所有时间都用来写论文了。但是论文进度比想象的慢，写作效率不高，可以形容为”&lt;strong&gt;以写论文的名义划水&lt;/strong&gt;“。&lt;/p&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://www.kherrisan.cn/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
      <category term="考研" scheme="http://www.kherrisan.cn/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="复习" scheme="http://www.kherrisan.cn/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="记录" scheme="http://www.kherrisan.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="日常" scheme="http://www.kherrisan.cn/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>2019年4月19日周记</title>
    <link href="http://www.kherrisan.cn/2019/04/19/2019%E5%B9%B44%E6%9C%8819%E6%97%A5%E5%91%A8%E8%AE%B0/"/>
    <id>http://www.kherrisan.cn/2019/04/19/2019%E5%B9%B44%E6%9C%8819%E6%97%A5%E5%91%A8%E8%AE%B0/</id>
    <published>2019-04-19T22:55:29.000Z</published>
    <updated>2020-05-03T08:41:45.622Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>为了能够记录自己平时的学习和生活，并进行一些有益的反思，我开始尝试写周记，同时也真心希望自己能够坚持下去。</p><a id="more"></a><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>周记正文内容所涵盖的开始时间为本周周一，结束时间为本周周日。</p><h2 id="2019年4月15日-2019年4月21日"><a href="#2019年4月15日-2019年4月21日" class="headerlink" title="2019年4月15日-2019年4月21日"></a>2019年4月15日-2019年4月21日</h2><p>本周是开始考研复习的第二周，总得来说，复习任务安排不够饱和，负载不够均衡，没有严格按照时间安排。经过反思之后发现有以下几个具体的问题：</p><ol><li><strong>没有正式地背单词。</strong> 仅仅使用扇贝单词app在空闲时间背单词。这里的空闲时间大部分都安排在图书馆和食堂之间的通勤过程中。虽然利用了这一块时间，但一边走路一边背单词的效率并不是很高。对单词的例句没有作适当的记忆。</li><li><strong>对高数的复习没有做到层次化、渐进式。</strong> 目前这一阶段的安排是先看汤家凤视频并做笔记，然后看李永乐全书上的内容并完成全书上的例题和习题。但实际操作中发现视频中的授课内容和全书中的内容的难度差异巨大，导致无法充分发挥全书上题目的练习作用。</li><li><strong>多次违反了时间安排。</strong> 没有严格按照时间安排进行学习。导致复习工作不够饱和，有些“三天打鱼两天晒网”的意思。睡觉不够早，起床也不够早。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;起因&quot;&gt;&lt;a href=&quot;#起因&quot; class=&quot;headerlink&quot; title=&quot;起因&quot;&gt;&lt;/a&gt;起因&lt;/h2&gt;&lt;p&gt;为了能够记录自己平时的学习和生活，并进行一些有益的反思，我开始尝试写周记，同时也真心希望自己能够坚持下去。&lt;/p&gt;
    
    </summary>
    
    
      <category term="周记" scheme="http://www.kherrisan.cn/categories/%E5%91%A8%E8%AE%B0/"/>
    
    
      <category term="考研" scheme="http://www.kherrisan.cn/tags/%E8%80%83%E7%A0%94/"/>
    
      <category term="复习" scheme="http://www.kherrisan.cn/tags/%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="记录" scheme="http://www.kherrisan.cn/tags/%E8%AE%B0%E5%BD%95/"/>
    
      <category term="日常" scheme="http://www.kherrisan.cn/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>Apple产品体验</title>
    <link href="http://www.kherrisan.cn/2019/04/06/Apple%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C/"/>
    <id>http://www.kherrisan.cn/2019/04/06/Apple%E4%BA%A7%E5%93%81%E4%BD%93%E9%AA%8C/</id>
    <published>2019-04-06T15:58:00.000Z</published>
    <updated>2020-05-03T08:41:45.622Z</updated>
    
    <content type="html"><![CDATA[<p>（挖坑待填）</p>]]></content>
    
    <summary type="html">
    
      
      
        
        
          &lt;p&gt;（挖坑待填）&lt;/p&gt;

        
      
    
    </summary>
    
    
      <category term="日常" scheme="http://www.kherrisan.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="http://www.kherrisan.cn/tags/%E6%97%A5%E5%B8%B8/"/>
    
  </entry>
  
  <entry>
    <title>休息一年，然后回来</title>
    <link href="http://www.kherrisan.cn/2019/04/06/%E4%BC%91%E6%81%AF%E4%B8%80%E5%B9%B4%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9B%9E%E6%9D%A5/"/>
    <id>http://www.kherrisan.cn/2019/04/06/%E4%BC%91%E6%81%AF%E4%B8%80%E5%B9%B4%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9B%9E%E6%9D%A5/</id>
    <published>2019-04-06T14:32:26.000Z</published>
    <updated>2020-05-03T08:41:45.630Z</updated>
    
    <content type="html"><![CDATA[<p>本来在大三时打定主意，本科毕业了之后就直接参加工作，迅速进入资本积累的人生阶段。结果在大四秋招之后对职业生涯却产生了新的理解和认识。人生应该不至于此，我决定参加2019年考研。</p><a id="more"></a><h1 id="故事"><a href="#故事" class="headerlink" title="故事"></a>故事</h1><p><img src="http://ipic.dokyme.cn/2019-04-09-134146.jpg" alt></p><p>秋招本身的过程是十分坎坷的。我从九月初开始陆续投简历，参加笔试、面试。因为对自己专业水平的错误评估，以及自己有一定好高骛远、心高气傲的态度，没有”海投简历”，而只是把赌注下在了那些业内人耳熟能详的大厂上面。</p><p>结果自然是，<strong>缺乏面试经验，专业基础知识不够扎实，还对面试有天生抗性的我，被大厂拒了个遍。</strong> 自我认识出现了偏差，最后的责任自然只有我能够承担。</p><p>2018年10月找到工作之后，笔试面试的压力逐渐变小，再加上还要应对KXD的实习，我也开始松懈了下来。虽然offer不是来自什么大厂，但好歹也算是对应领域的头部公司，且公司主要围绕的两大核心——区块链技术和数字加密货币交易业务都非常地合我胃口，工资待遇不低，地处北京未来可期。面试时与面试官的亲切交谈也让我对这家公司产生了相当不错的初步感受。</p><p><img src="http://ipic.dokyme.cn/2019-04-09-134209.jpg" alt></p><p>我有个亲戚在字节跳动工作，他在了解到了我的情况之后，给我的意见是“毕业之后的第一份工作一定要去大公司”。他从内部情况、职业发展的角度解释了“大公司”的好处。我当时觉得他的建议和理由有一定的道理，但也仅仅是有一定的道理。毕竟上升和成长主要还是靠自己的努力。我当时还没有其他的想法。</p><p><img src="http://ipic.dokyme.cn/2019-04-09-134303.jpg" alt></p><p>（这里盗用一下富士康的图）</p><p>大概在十一月份的时候，我在b站上看到了一个视频。加拿大白嫖王Linus去参观一加手机的生产车间。一加手机的装配流程采用人工流水线的形式，每个工人从流水线中取下一部手机，安装上自己负责的组件，再将其放回流水线。工序被划分的很细，安装一个组件和整理该组件连接线都被分配给了两个人做。联系到软件开发行业的工作，又何尝不是这样的呢。</p><p>在一个稍显复杂的系统中，每一个研发工程师都只负责开发其中的一个模块，这个模块如一个螺丝一般细小，但又的确不可或缺。模块是不可或缺的，但人不是。高薪的互联网研发岗位吸引了大量的劳动力，供过于求，单位就只能提高招聘门槛来筛选人才。</p><p><img src="http://ipic.dokyme.cn/2019-04-09-092229.jpg" alt></p><p><strong>“面试造火箭，工作拧螺丝”</strong>。说的就是这个意思。</p><p>拧螺丝不是什么可怕的事情，可怕是拧一辈子的螺丝而浑然不知，甚至是拧了几年的螺丝，忽然就失业了。试想那些流水线上的装配工人，有几个能在日复一日的手机装配工序中，总结出手机内部组件编排设计的规律或者原理，进而成为一个扫地僧式的人物？不可能的，因为核心技术不在这里，另外技术门槛也高。那换一个角度看，能否就沿着普通的管理人员的发展道路走呢？看似行的通，但实际上难度也不小，毕竟僧多粥少。</p><p>凭什么你能上别人不能上？对个人综合能力的评估是一件复杂的事情，虽说现在有科学客观的评估方法，但有时就是<strong>说不清道不明</strong>。不会有多少人能够搞清楚各个指标在各个方向上占多少权重，大多数人能做到的是尽可能地让每个指标都变得更漂亮一些。</p><p>学历就是一个非常重要的指标。有多重要呢？根据我个人的估计和在面“网易”时与面试官的交流，至少进入面试阶段与我“同台竞技”的同学中，<strong>十个有九个是研究生，剩下一个是本科生的我</strong>。</p><h1 id="社会关系"><a href="#社会关系" class="headerlink" title="社会关系"></a>社会关系</h1><blockquote><p>人的本质是一切社会关系的总和，不是鸽子，亦不是复读机。——马克思</p></blockquote><p><img src="http://ipic.dokyme.cn/2019-04-09-134339.jpg" alt></p><p>我在大学本科四年中没有正确地处理好所有的社会关系，或者说没有有意培养处理各种关系的能力。<a href><strong>直到大四才意识到处理好关系的重要性</strong></a>。</p><p>当然，能力的培养可以在学校，也可以在社会，社会有社会的关系，最典型的如工作和生活之间的二元关系。学校里也有学校所特有的关系，社会环境和校园环境没有高低之分。我知道人总是要走进社会的，只是不读研究生的话，学校里的一些关系很有可能这辈子都接触不到了。</p><h1 id="取之其上"><a href="#取之其上" class="headerlink" title="取之其上"></a>取之其上</h1><blockquote><p>“取之其上，得之其中；取之其中，得之其下”。</p></blockquote><p><img src="http://ipic.dokyme.cn/2019-04-09-101310.jpg" alt></p><p>在我爸那个年代，走出校园之后安安稳稳地在一个岗位上干一辈子是非常常见的。而在市场经济高度发达的今天，这样的人几乎只存在于文学作品以及宣传劳模的媒体报道中，不想着职业的成长和发展，不想“往上升”，就会“被别人踩在脚下”。</p><p>若是只想着在一个岗位上安安稳稳地干下去，那么按照取其上得其中的规律，结合如今的社会生活实践，很有可能做不到“安稳”。</p><p>有个高速公路收费站要取消了，需要安排那里的工作人员再就业，“我在收费站工作了二十年，现在你说取消就取消了？我今年40了，你说还有哪个单位要我这么大的人？我这二十年只会收费，你说这个职业技能哪个单位要？”。</p><p><strong>所以说，人还是要有远大的理想，不仅仅是为了实现人生价值，更是让自己的努力和奋斗所带来的“成果支票”能够有一定的冗余和保障。</strong></p><p>我在高中之前的理想都是瞎想，高中时期只想着考上一个好大学，从未思考过职业规划。大学时我对自己的职业规划就是简单的 <strong>“进入BAT，升职加薪，迎娶白富美，走上人生巅峰”</strong>。产生这个想法的原因有以下几点：</p><ol><li>程序员工资水平很高，自给自足不愁。</li><li>软件和互联网在当前还是代表着最为先进的生产力水平，短时间不会被淘汰。</li><li>我是软件工程专业的，有能力写好代码，干好活儿。</li></ol><p>这三点认识本身没有什么大问题，问题在于仅带着这三点认识就匆忙进入职场，可能会使视野受到局限。</p><p>我出生在一个传统家庭，因为和爷爷奶奶生活在一起，因此很多生活习惯和思想观念都比较接近老一代。老一代的职业观念就是找一个稳当的工作，定定心心地赚钱，买车买房结婚生子，安安稳稳过日子。在和亲戚朋友的交谈中感受到了 <strong>“钱”和地位</strong> 的重要性。房子大，存款多，开公司当老板，人脉广有抓手，自然就有话语权。这也使得作为普通工薪阶层的我的父母常常是饭桌上默默无闻的那几个人。</p><p>家长所处社会地位的制约导致我在进入了大学之后很难从他们那里得到足够的指导，同时我的自身的思想也还是深深地受传统观念影响。再加上我天生内向，在学校也很少与学长和老师做深入交流，只凭知乎等网络信息渠道获得的信息还不足以驱动我去做出改变。</p><p><strong>宽阔的视野是树人、成材之路上的必要因素</strong>，甚至比挣钱的能力更重要。程序员因为与网络较为接近，接触信息的渠道比其他行业的人更加丰富多样，但我认为仅仅这样还不够。拓宽视野的重要步骤是实践，而<strong>以996闻名的程序员是否具有实践的时间和精力，这点是值得怀疑的</strong>。由于我目前较为薄弱的处理工作和生活这二者之间关系的能力，在参加工作之后很有可能导致二者失衡。</p><p>是的，我还需要锻炼，还需要成长，但我怕在有的地方一忙起来就得不到成长。</p><h1 id="野心膨胀"><a href="#野心膨胀" class="headerlink" title="野心膨胀"></a>野心膨胀</h1><p>说着说着，我对权利和财富的欲望就开始膨胀起来了。其实我觉得欲望的膨胀不是坏事，取之有道即可。人这一生只有一次，不抓紧机会走上人生巅峰，可没有第二次膨胀的机会。</p><h1 id="路在何方"><a href="#路在何方" class="headerlink" title="路在何方"></a>路在何方</h1><p>当然，大四没有保研，结果现在选择了毕业之后考研的道路，<strong>说到底就是走了弯路</strong>。给这个东西定性的话应该说：因为自己对自我水平和社会环境的认知出现了偏差，导致做出了错误的选择，不过人的认识本身就是随着社会大环境和个人小情况的发展而不断变化的，现在认识到了这些，也不算晚。<strong>眼前有路，就上</strong>。</p><p><strong>但我认为过程也是很重要的，四年课不是白上的，五万行代码也不是白写的。</strong></p><p>如果我考上了研究生的话，我认为还是存在两种可能性。</p><ol><li>研究生毕业，仍然去互联网公司做研发岗。目前我不是很希望自己走到这条路上，我一直想 <strong>“站着把钱挣了”</strong>。</li><li>若是家里条件允许，并且自身条件合适，则继续深造。</li></ol><p>但无论走哪一条路，我都希望我能够以一个不同于现在的面貌去应对。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本来在大三时打定主意，本科毕业了之后就直接参加工作，迅速进入资本积累的人生阶段。结果在大四秋招之后对职业生涯却产生了新的理解和认识。人生应该不至于此，我决定参加2019年考研。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常" scheme="http://www.kherrisan.cn/categories/%E6%97%A5%E5%B8%B8/"/>
    
    
      <category term="日常" scheme="http://www.kherrisan.cn/tags/%E6%97%A5%E5%B8%B8/"/>
    
      <category term="成长" scheme="http://www.kherrisan.cn/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>如何看待江苏要南京提高首位度？</title>
    <link href="http://www.kherrisan.cn/2019/01/27/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%B1%9F%E8%8B%8F%E8%A6%81%E5%8D%97%E4%BA%AC%E6%8F%90%E9%AB%98%E9%A6%96%E4%BD%8D%E5%BA%A6%EF%BC%9F/"/>
    <id>http://www.kherrisan.cn/2019/01/27/%E5%A6%82%E4%BD%95%E7%9C%8B%E5%BE%85%E6%B1%9F%E8%8B%8F%E8%A6%81%E5%8D%97%E4%BA%AC%E6%8F%90%E9%AB%98%E9%A6%96%E4%BD%8D%E5%BA%A6%EF%BC%9F/</id>
    <published>2019-01-27T20:31:04.000Z</published>
    <updated>2020-05-03T08:41:45.630Z</updated>
    
    <content type="html"><![CDATA[<p>这个主题来自<a href="https://www.zhihu.com/question/266051194">知乎</a>，今天在回家的高铁上偶然刷到。作为一个在南京生活了3年半的土生土长的常州人，我想围绕这个主体就知乎上的一些回答给出我自己的些许看法。</p><a id="more"></a><h2 id="关于首位度（Primary-Ratio）"><a href="#关于首位度（Primary-Ratio）" class="headerlink" title="关于首位度（Primary Ratio）"></a>关于首位度（Primary Ratio）</h2><blockquote><p>首位度在一定程度上代表了城镇体系中的城市发展要素在最大城市的集中程度。——百度百科</p></blockquote><p>早在1939年，马克·杰斐逊（M.Jefferson）就在<a href="https://www.mendeley.com/catalogue/geography-law-primate-city/">《Why Geography? The Law of the Primate City》</a>一文中提出了<strong>城市首位律（Law of the Primate City）</strong>的概念。他发现，一个国家的“首位城市”往往会比第二位以及排位更靠后的城市大很多，会拉开一段差距。为了衡量发展要素在最大城市的集中程度，他定义了“两城市指数”：首位城市和第二位城市的人口规模之比。很显然，两城市指数越大，说明首位城市和其他城市的差距越大，资源越集中，首位度越强。</p><p>城市首位律更多的只是提出了首位度这个概念，至于这个度应该在怎样的水平最为合适，学术界一直存在争论。大致的分析角度有：规模经济与聚集经济、城市位序规模分布。</p><h2 id="南京首位度"><a href="#南京首位度" class="headerlink" title="南京首位度"></a>南京首位度</h2><p>江苏是一个GDP大省，从省总量上看，常年居全国第二，仅次于广东省。从省内来看，南京作为省会在科教文卫上处于省内的领先地位，其中教育更是能够排到全国TOP3。与高度发达城市功能相对应的，南京的GDP却多年不及苏州，且与后继城市如无锡、南通、常州之间的差距不是特别大。</p><p><img src="http://ipic.dokyme.cn/2019-01-27-134336.jpg" alt></p><p>最近几年<strong>南京的首位度</strong>的相关问题也正在被有关领导重视起来。</p><p><a href="https://v.youku.com/v_show/id_XMzg4OTg2ODc4NA==.html">十九届中央第一轮巡视整改 江苏：整改省会城市功能发挥不够 20181027</a></p><p>巡视组提出的要求是要推动南京交通建设，支持创新发展，加快产业升级，结合GDP不及苏州这一现象来看，南京的短板应该是在产业结构上。</p><h2 id="南京产业结构"><a href="#南京产业结构" class="headerlink" title="南京产业结构"></a>南京产业结构</h2><p>南京本身是一个制造业相对发达的城市，重工业、化工业占较大比重，自然资源比较匮乏。改革开发以来，南京的经济也随着市场发展逐步向<strong>集约型</strong>（提高生产要素质量和生产效率，而不是扩大生产要素规模）转变。</p><h4 id="优化产业结构"><a href="#优化产业结构" class="headerlink" title="优化产业结构"></a>优化产业结构</h4><p>2008年南京的一二三产业GDP比重为2.5：47.5：50，呈现“三二一“的结构形态。其中<strong>行业增加值占第三产业比重最大的五个行业为：批发零售、金融、交通仓储邮政、房地产、教育</strong>。</p><p>“十二五”以来，南京新兴产业发展迅猛，以<strong>信息技术</strong>为代表的七大类战略性新兴产业占比首次超过石化、钢铁、建材等传统制造业，2016年占比达到40%左右。</p><p>2017年南京服务业增长10.3%，比第二产业高出5.2个点，占GDP比重达到59.7%。传统服务业如贸易、交通、房地产、教育等稳定增长，对总体经济运行起到稳定作用。同时现代服务业如信息、商务、金融等对增长贡献较大。当年一二三产业占GDP比重为2.3：38.0：59.7。</p><h4 id="扩大有效需求"><a href="#扩大有效需求" class="headerlink" title="扩大有效需求"></a>扩大有效需求</h4><p>近年来，南京的旅游消费不断升温，传统的有名的旅游项目（如夫子庙、中山陵、总统府）继续保持热度，每年吸引大批游客。新增的项目如牛首山、大报恩寺等则进一步增强了南京的旅游吸引力。每年的元宵节夫子庙都会有灯会，华丽的灯光下游人如织，场面堪比上海世博会，这也从侧面说明只要继续挖掘潜力，积极探索现有条件下新形式的旅游项目，南京的旅游市场还能够得到巨大的提升。在旅游项目中，培育服务消费、信息消费、绿色消费，推动消费升级。</p><h4 id="激励创新驱动"><a href="#激励创新驱动" class="headerlink" title="激励创新驱动"></a>激励创新驱动</h4><p>南京拥有位于全国第一梯队的科教力量，且在很长一段时间内其地位不会产生太大变化。如果能够将人才“留住”，同时吸引海内外优秀人才，那必然能够为长期稳定高质量的经济发展提供可靠保障。在雨花台区软件大道两侧，有华为南研所、中兴云计算中心；在河西有小米、阿里巴巴江苏总部（在建）；在江宁，有无线谷（我东南边）。越来越多的公司开始重视在南京的投入，“近水楼台先得月”，这也为每年南京的高校毕业生提供了丰富的择业选择。</p><p>推动创新创业靠人才，激励创新创业靠政策。近年来多个创新创业园区在南京成立，配合优惠政策，能够集中资源，吸引高潜力创新企业。优质人才和企业的流向，就是未来的流向。</p><h2 id="如何看待"><a href="#如何看待" class="headerlink" title="如何看待"></a>如何看待</h2><p>江苏要求南京提高首位度的这个意见，的确会对南京的方方面面产生影响。“揣摩上意“的话：在江苏省这样一个沿海大省，需要一个像样的带头城市，<strong>使其在充分发挥自身区位优势的同时，带动周边地区的发展</strong>，诸如苏北的几个城市以及与安徽省邻接的马鞍山、芜湖、宣城等。南通近几年经济的迅猛发展，我认为很大程度上就是得益于上海的辐射效应，不过南通的产业结构与南京存在差距（南通六大产业：船舶海工、高端纺织、电子信息、智能装备、新材料），政治经济条件上差距也较大。</p><p>从地图上看，苏锡常与上海较为接近，因此很自然地与上海结成“环沪都市圈”，南京若是想要提高首位度，必然需要与周边城市展开合作，扩大自身影响力的同时在一定程度上吸收优势条件。即知乎上所说的“吸血”。事实上，<strong>南京凭借目前的水平，已经有足够的吸引力，能够在现有的形式下保持对资源的强大竞争力。因此人才和资本的富集是在所难免的。</strong></p><p>富集是在所难免的，北上广深作为排头兵，一直有源源不断的人才和资本涌入，除非政策调控，否则会一直保持这样的趋势。自上海发达以来，昆山、苏州近水楼台，发展速度相对较快。如果南京也能够立足苏中，成为地区心脏，那对于江苏的发展来说是大有裨益的。南京应该成为一个国家层面的城市，增强话语权，成为苏皖交接的一颗明珠。城市发达了，话语权响亮了，地位上升了，才不会错过历史发展的机遇。</p><p>至于说什么和上海展开竞争，我觉得还是团结一些比较好。</p><hr><p>随意想想，现在阻挡我入户上海的唯一客观因素就是房价，可能这也是绝大多数人望而却步的原因。南京房价相比于上海“天价”还是有些遥远，但也已经进入跑道，准备起飞了。当然房价受大环境和政策影响较大，但也会在很大程度上受城市综合水平影响。如果让我选择未来定居的地方，南京是我第一选择，常州第二。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个主题来自&lt;a href=&quot;https://www.zhihu.com/question/266051194&quot;&gt;知乎&lt;/a&gt;，今天在回家的高铁上偶然刷到。作为一个在南京生活了3年半的土生土长的常州人，我想围绕这个主体就知乎上的一些回答给出我自己的些许看法。&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>这是一个测试页</title>
    <link href="http://www.kherrisan.cn/2019/01/24/test/"/>
    <id>http://www.kherrisan.cn/2019/01/24/test/</id>
    <published>2019-01-24T13:46:26.000Z</published>
    <updated>2020-05-03T08:41:45.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown语法渲染"><a href="#Markdown语法渲染" class="headerlink" title="Markdown语法渲染"></a>Markdown语法渲染</h2><p>这部分主要是为了测试Hexo渲染Markdown的编译器对常用记号的支持程度。</p><p>各级标题</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><a id="more"></a><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p>引用</p><blockquote><p>白求恩同志是加拿大共产党员，五十多岁了，为了帮助中国的抗日战争，受加拿大共产党和美国共产党的派遣，不远万里，来到中国。去年春上到延安，后来到五台山工作，不幸以身殉职。一个外国人，毫无利己的动机，把中国人民的解放事业当做他自己的事业，这是什么精神？这是国际主义的精神，这是共产主义的精神，每一个中国共产党员都要学习这种精神。列宁主义认为：资本主义国家的无产阶级要拥护殖民地人民的解放斗争，殖民地半殖民地的无产阶级要拥护资本主义国家的无产阶级的解放斗争，世界革命才能胜利。白求恩同志是实践了这一条列宁主义路线的。我们中国共产党员也要实践这一条路线。我们要和一切资本主义国家的无产阶级联合起来，要和日本的、英国的、美国的、德国的、意大利的以及一切资本主义国家的无产阶级联合起来，才能打倒帝国主义，解放我们的民族和人民，解放世界的民族和人民。这就是我们的国际主义，这就是我们用以反对狭隘民族主义和狭隘爱国主义的国际主义。</p></blockquote><p>列表</p><ul><li>jekyll</li><li>hexo</li><li>hugo</li><li>wordpress</li></ul><ol><li><p>c++</p></li><li><ol><li>VisualStudio</li></ol></li><li><p>Java</p></li><li><ol><li>IDEA</li></ol></li><li><p>Python</p></li><li><ol><li><p>Pycharm</p><p>Pycharm的第二段落</p><blockquote><p>Pycharm的第三段落</p></blockquote></li></ol></li><li><p>PHP</p></li></ol><p>代码区块（缩进）</p><pre><code>public class Server{    public static void main(String[] args){        System.out.println("Hello World");    }}</code></pre><p>代码区块（`)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>{</span><br><span class="line">        System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>分割线</p><hr><p>链接</p><p>This is <a href="http://example.com/" title="Title">an example</a> inline link.</p><p>This is <a href="http://example.com/" title="Optional Title Here">an example</a> reference-style link.</p><p>强调</p><p>宫中府中，俱为一体，陟罚臧否，不宜异同。<strong>若有作奸犯科及为忠善者</strong>，宜付有司论其刑赏，以昭陛下平明之理，<em>不宜偏私，使内外异法也</em>。</p><h2 id="前端加载"><a href="#前端加载" class="headerlink" title="前端加载"></a>前端加载</h2><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/2019-01-23-121710.jpg" alt="中等图片"></p><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/2019-01-23-123408.jpg" alt="大型图片"></p><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>测试一下持续集成。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown语法渲染&quot;&gt;&lt;a href=&quot;#Markdown语法渲染&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法渲染&quot;&gt;&lt;/a&gt;Markdown语法渲染&lt;/h2&gt;&lt;p&gt;这部分主要是为了测试Hexo渲染Markdown的编译器对常用记号的支持程度。&lt;/p&gt;
&lt;p&gt;各级标题&lt;/p&gt;
&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;
    
    </summary>
    
    
      <category term="测试" scheme="http://www.kherrisan.cn/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="测试" scheme="http://www.kherrisan.cn/tags/%E6%B5%8B%E8%AF%95/"/>
    
      <category term="Markdown" scheme="http://www.kherrisan.cn/tags/Markdown/"/>
    
      <category term="前端" scheme="http://www.kherrisan.cn/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="优化" scheme="http://www.kherrisan.cn/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Netty——Pipeline(1)</title>
    <link href="http://www.kherrisan.cn/2019/01/08/netty-pipeline/"/>
    <id>http://www.kherrisan.cn/2019/01/08/netty-pipeline/</id>
    <published>2019-01-08T22:25:02.000Z</published>
    <updated>2020-05-03T08:41:45.626Z</updated>
    
    <content type="html"><![CDATA[<p>)Netty中使用Handler对数据包进行处理，每个Handler成为整个处理过程的一个阶段，几个Handler前后相连构成了一个处理数据包的流水线（Pipeline）。同一个Handler实现可以在多种不同的处理流程中发挥自身的局部作用，可复用。 <code>Pipeline</code>的继承结构： <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/e1fb7cb818b3cd0d10e25e3905f0efcb.png" alt></p><a id="more"></a><h1 id="第一个Pipeline"><a href="#第一个Pipeline" class="headerlink" title="第一个Pipeline"></a>第一个Pipeline</h1><p>同样的，还是先寻找第一个<code>Pipeline</code>是在什么地方创建并初始化的。从我对Netty的了解来看，应该是<code>Channel</code>和<code>Pipline</code>之间关联较大，可能会具有一对一的关系。要么是<code>NioServerSocketChannel</code>，要么是它的某个父类。最终在<code>AbstractChannel</code>中找到了它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> DefaultChannelPipeline pipeline;</span><br></pre></td></tr></table></figure><p>倒也是直接，声明类型就是<code>DefaultChannelPipeline</code>，没有声明为其父类，说明<code>Pipeline</code>可能没有较多的多态特性需要表现出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    id = newId();</span><br><span class="line">    unsafe = newUnsafe();</span><br><span class="line">    pipeline = newChannelPipeline();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DefaultChannelPipeline <span class="title">newChannelPipeline</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelPipeline(<span class="keyword">this</span>);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>每个<code>AbstractChannel</code>对象都有一个属于自己的<code>Pipeline</code>，并且在它的构造函数中实例化pipeline对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.channel = channel;</span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    tail = <span class="keyword">new</span> TailContext(<span class="keyword">this</span>);</span><br><span class="line">    head = <span class="keyword">new</span> HeadContext(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    head.next = tail;</span><br><span class="line">    tail.prev = head;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>至此第一个<code>Pipeline</code>诞生，这个<code>Pipeline</code>中只有两个节点：head和tail。<code>Pipeline</code>中的节点以双向链表的形式相连。</p><h1 id="第一次插入节点"><a href="#第一次插入节点" class="headerlink" title="第一次插入节点"></a>第一次插入节点</h1><p>下面来探索第一次向该<code>Pipeline</code>中插入节点的场景。在netty启动的过程中，<code>AbstractBootstrap</code>的<code>initAndRegister</code>方法会调用<code>ServerBootstrap</code>中的<code>init</code>方法，该方法第一次向<code>Pipeline</code>中插入元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        ......</span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelInitializer<Channel>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) {</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>init</code>方法的参数<code>channel</code>是刚刚通过反射创建出来的<code>NioServerSocketChannel</code>对象，该对象具有一个<code>Pipeline</code>对象，现在在这个pipeline的尾部插入一个<code>ChannelInitializer</code>，并且在将来的某个时候，会调用这个initializer的<code>initChannel</code>方法，执行重写的代码。 暂时不去理会重写的代码什么时候执行，先搞清楚<code>addLast</code>方法做了什么事情。在深入了几个重载函数之后，看到了<code>addLast</code>的真身：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">addLast</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> AbstractChannelHandlerContext newCtx;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) {</span><br><span class="line">        checkMultiplicity(handler);</span><br><span class="line"></span><br><span class="line">        newCtx = newContext(group, filterName(name, handler), handler);</span><br><span class="line"></span><br><span class="line">        addLast0(newCtx);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the registered is false it means that the channel was not registered on an eventloop yet.</span></span><br><span class="line">        <span class="comment">// In this case we add the context to the pipeline and add a task that will call</span></span><br><span class="line">        <span class="comment">// ChannelHandler.handlerAdded(...) once the channel is registered.</span></span><br><span class="line">        <span class="keyword">if</span> (!registered) {</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            callHandlerCallbackLater(newCtx, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        EventExecutor executor = newCtx.executor();</span><br><span class="line">        <span class="keyword">if</span> (!executor.inEventLoop()) {</span><br><span class="line">            newCtx.setAddPending();</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    callHandlerAdded0(newCtx);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    callHandlerAdded0(newCtx);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkMultiplicity</span><span class="params">(ChannelHandler handler)</span> </span>{</span><br><span class="line">        ChannelHandlerAdapter h = (ChannelHandlerAdapter) handler;</span><br><span class="line">        <span class="keyword">if</span> (!h.isSharable() && h.added) {</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelPipelineException();</span><br><span class="line">        }</span><br><span class="line">        h.added = <span class="keyword">true</span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, childExecutor(group), name, handler);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>addLast</code>并不仅仅是将新的handler插入到链表中，还做了一些其他的事情：</p><ol><li><code>checkMultiplicity</code>，检查该handler对象有没有被插入过，不管是该pipeline还是其他的pipeline。在netty中，只有被<code>@Sharable</code>注解的handler才可以被复用到pipeline中，否则一个handler对象只能出现在一处。这么做是为了保证状态变量的线程安全。</li><li><code>newContext</code>，用一个<code>ChannelHandlerContext</code>对象来包裹这个handler。</li><li><code>addLast0</code>，在链表中插入这个<code>ChannelHandlerContext</code>。</li><li>检查pipeline有没有完成到某个<code>NioEventloop</code>的注册，即channel有没有注册到<code>NioEventloop</code>。 3.1. 如果没有注册，那么<code>handlerAdded</code>的回调函数是不能立刻调用的，因为还没有eventloop线程实体与之绑定——在netty中各种事件的回调函数都是在<code>NioEventloop</code>中调用的，在以后还会遇到很多体现这个特征的场景。 3.2. 如果已经注册过了，在eventloop中调用<code>callHandlerAdded0</code>。</li></ol><p>这里遇到了一个类<code>DefaultChannelHandlerContext</code>，这个类的地位十分重要，承担了维系pipeline和handler的工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DefaultChannelHandlerContext(</span><br><span class="line">        DefaultChannelPipeline pipeline, EventExecutor executor, String name, ChannelHandler handler) {</span><br><span class="line">    <span class="keyword">super</span>(pipeline, executor, name, isInbound(handler), isOutbound(handler));</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"handler"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AbstractChannelHandlerContext(DefaultChannelPipeline pipeline, EventExecutor executor, String name,</span><br><span class="line">                              <span class="keyword">boolean</span> inbound, <span class="keyword">boolean</span> outbound) {</span><br><span class="line">    <span class="keyword">this</span>.name = ObjectUtil.checkNotNull(name, <span class="string">"name"</span>);</span><br><span class="line">    <span class="keyword">this</span>.pipeline = pipeline;</span><br><span class="line">    <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    <span class="keyword">this</span>.inbound = inbound;</span><br><span class="line">    <span class="keyword">this</span>.outbound = outbound;</span><br><span class="line">    <span class="comment">// Its ordered if its driven by the EventLoop or the given Executor is an instanceof OrderedEventExecutor.</span></span><br><span class="line">    ordered = executor == <span class="keyword">null</span> || executor <span class="keyword">instanceof</span> OrderedEventExecutor;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>AbstractChannelHandlerContext</code>维护了pipeline对象，表明他是属于这个pipeline的一个节点，以后若是有需要可以直接通过这个pipeline成员调用其方法。netty中的handler可以分为两类：<code>inbound</code>和<code>outbound</code>（当然有的handler可以同时具有这两种特性），为了区分包含的handler的方向，<code>AbstractChannelHandlerContext</code>使用了两个boolean，由于之前括号里的情况存在，显然一个boolean是不够的。此外，<code>AbstractChannelHandlerContext</code>还有一个executor，这个executor是pipeline通过<code>childExecutor</code>方法分配给他的，这里先不谈分配方式。 再来看<code>addLast0</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addLast0</span><span class="params">(AbstractChannelHandlerContext newCtx)</span> </span>{</span><br><span class="line">    AbstractChannelHandlerContext prev = tail.prev;</span><br><span class="line">    newCtx.prev = prev;</span><br><span class="line">    newCtx.next = tail;</span><br><span class="line">    prev.next = newCtx;</span><br><span class="line">    tail.prev = newCtx;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>有数据结构基础的人都能够很快理解这段代码，对于没有学过数据结构的人来说双向链表的插入操作也不是很难。 停！现在来给pipeline拍一张快照： <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/44464b519546afc2bfeed5d917c1cd5f.png" alt> 现在pipeline中有三个节点，其中<code>HeadContext</code>和<code>TailContext</code>都是没有handler的，中间的<code>HandlerContext</code>包含一个<code>ChannelInitializer</code>。 在链表中插入了新的handlerContext之后，需要决定是否需要调用它的<code>handlerAdded</code>方法。如果暂时不调用回调方法的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerCallbackLater</span><span class="params">(AbstractChannelHandlerContext ctx, <span class="keyword">boolean</span> added)</span> </span>{</span><br><span class="line">    PendingHandlerCallback task = added ? <span class="keyword">new</span> PendingHandlerAddedTask(ctx) : <span class="keyword">new</span> PendingHandlerRemovedTask(ctx);</span><br><span class="line">    PendingHandlerCallback pending = pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">if</span> (pending == <span class="keyword">null</span>) {</span><br><span class="line">        pendingHandlerCallbackHead = task;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="keyword">while</span> (pending.next != <span class="keyword">null</span>) {</span><br><span class="line">            pending = pending.next;</span><br><span class="line">        }</span><br><span class="line">        pending.next = task;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>handlerContext会被包装成一个<code>PendingHandlerCallback</code>，插入到由pipeline维护的<code>PendingHandlerCallback</code>的链表的末尾。 如果我们在pipeline注册到eventloop之前，在pipeline中插入多个handler，那么这些handler的<code>handlerAdded</code>方法都会被包装成pendingTask，接续到链表后。同样的，如果是在注册之前删除某个handler，它的<code>handlerRemoved</code>也会被包装，并插入链表。 <strong>我认为这么做的目的是保证在注册前发生的add和remove操作都会导致其对应事件的回调函数能够被正确的调用，这里的正确指的是按照正确的顺序在eventloop中调用。不能因为某个handler先被add然后被remove就认为它从没有出现过。</strong> 当然了，也有可能注册得比较早，那么<code>handlerAdded</code>方法可以立刻执行，没有必要等什么。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EventExecutor executor = newCtx.executor();</span><br><span class="line"><span class="keyword">if</span> (!executor.inEventLoop()) {</span><br><span class="line">    newCtx.setAddPending();</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            callHandlerAdded0(newCtx);</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">}</span><br><span class="line">callHandlerAdded0(newCtx);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAdded0</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext ctx)</span> </span>{</span><br><span class="line">        ......</span><br><span class="line">        ctx.handler().handlerAdded(ctx);</span><br><span class="line">        ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>现在，把时间轴向前推进，直接走到<code>initChannel</code>调用之前：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        doRegister();</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        ......</span><br><span class="line">    } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">        ......</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>invokeHandlerAddedIfNeeded</code>就是专门用来触发之前pending的<code>handlerAdded</code>事件的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">invokeHandlerAddedIfNeeded</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">assert</span> channel.eventLoop().inEventLoop();</span><br><span class="line">    <span class="keyword">if</span> (firstRegistration) {</span><br><span class="line">        firstRegistration = <span class="keyword">false</span>;</span><br><span class="line">        callHandlerAddedForAllHandlers();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>callHandlerAddedForAllHandlers</code>也的确只会被调用一次，就是在这里。在其他地方，handler的added事件不会延迟执行，是即时的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">callHandlerAddedForAllHandlers</span><span class="params">()</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    PendingHandlerCallback task = pendingHandlerCallbackHead;</span><br><span class="line">    <span class="keyword">while</span> (task != <span class="keyword">null</span>) {</span><br><span class="line">        task.execute();</span><br><span class="line">        task = task.next;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>沿着pendingTask的链表，逐个执行<code>handlerAdded</code>和<code>handlerRemoved</code>回调事件。当然这里的<code>execute</code>方法会保证在当前的eventloop中执行<code>handlerAdded</code>或<code>handlerRemoved</code>回调函数的代码。 <strong>也就是说，为了让handler的added和removed事件不遗漏、不乱序、串行地得到执行，netty采用将added和removed事件包装成pendingTask的方式，在pipeline注册到某个eventloop后，再在一个方法中去逐个回调pendingTask。</strong> 回到<code>ChannelInitializer</code>中，它的<code>handlerAdded</code>实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (ctx.channel().isRegistered()) {</span><br><span class="line">        initChannel(ctx);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>ChannelInitializer</code>作为一种特殊的handler，主要用于在channel启动时做一些初始化工作，为了达成这样的效果，它的做法是在它自身被插入到pipeline之后立即做<code>initChannel</code>操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            initChannel((C) ctx.channel()); <span class="comment">// 调用重写的initChannel方法</span></span><br><span class="line">        } <span class="keyword">catch</span> (Throwable cause) {</span><br><span class="line">            ......</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            remove(ctx); <span class="comment">// 把自己从pipeline中删掉</span></span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在<code>ServerBootstrap</code>中见到的<code>ChannelInitializer</code>匿名内部类的<code>initChannel</code>做了这些事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">ChannelHandler handler = config.handler();</span><br><span class="line"><span class="keyword">if</span> (handler != <span class="keyword">null</span>) {</span><br><span class="line">    pipeline.addLast(handler);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">ch.eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">    }</span><br><span class="line">});</span><br></pre></td></tr></table></figure><ol><li>从<code>config()</code>中取出一个handler，添加到pipeline的末尾。从调试时的结果来看，这是一个<code>LoggingHandler</code>（估计就是专门负责打日志的）。</li><li>异步地在pipeline末尾插入一个<code>ServerBootstrapAcceptor</code>。</li></ol><p>再给pipeline拍一张快照： <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/1d0c5dc9d01a99fbdf25dadaac0b36d9.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;)Netty中使用Handler对数据包进行处理，每个Handler成为整个处理过程的一个阶段，几个Handler前后相连构成了一个处理数据包的流水线（Pipeline）。同一个Handler实现可以在多种不同的处理流程中发挥自身的局部作用，可复用。 &lt;code&gt;Pipeline&lt;/code&gt;的继承结构： &lt;img src=&quot;https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/e1fb7cb818b3cd0d10e25e3905f0efcb.png&quot; alt&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="http://www.kherrisan.cn/categories/Netty/"/>
    
    
      <category term="java" scheme="http://www.kherrisan.cn/tags/java/"/>
    
      <category term="Netty" scheme="http://www.kherrisan.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>JLink——借助JLink打包Java程序为可执行程序</title>
    <link href="http://www.kherrisan.cn/2019/01/06/jlink/"/>
    <id>http://www.kherrisan.cn/2019/01/06/jlink/</id>
    <published>2019-01-06T19:38:54.000Z</published>
    <updated>2020-05-03T08:41:45.626Z</updated>
    
    <content type="html"><![CDATA[<p>JDK9中的模块化技术使得原本一两百兆的JRE能够被拆分成多个较小的模块，因此如果想要把Java程序打包成可执行程序，并在没有JRE环境的机器上运行，不再需要带上一个庞大的JRE，而只需要额外增加几个JDK中的module。 项目目录结构如下，仅仅是一个很简单的Hello World程序。代码中仅仅使用到了System.out.println这一个JDK中提供的函数。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/b6fc620903896d3ef034f5bed269fcaa.png" alt> 最重要的是module-info.jar文件，这个文件是module的定义文件，声明了我所编写的这个模块需要依赖哪些模块，以及对外暴露哪些东西。 由于只依赖java.base模块，而这个模块是默认包含的，因此module-info的大括号内可以为空。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> dkm {</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>build.gradle文件也十分简单。</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins {</span><br><span class="line">    id <span class="string">'java'</span></span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'application'</span></span><br><span class="line">mainClassName = <span class="string">'com.dokyme.Main'</span></span><br><span class="line"></span><br><span class="line">group <span class="string">'test-jlink-exe'</span></span><br><span class="line">version <span class="string">'1.0-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">sourceCompatibility = <span class="number">1.9</span></span><br></pre></td></tr></table></figure><p>先运行<code>./gradlew build</code>，将该项目打成JAR包。接着再用JLink工具将多个模块链接成一个可执行文件，有没有一种C语言的链接器的既视感？</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jlink <span class="params">--module-path</span> <span class="string">/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home/jmods</span><span class="function">:build</span>/libs <span class="params">--add-modules</span> dkm <span class="params">--launcher</span> dkm=dkm/com.dokyme.Main <span class="params">--output</span> dist</span><br></pre></td></tr></table></figure><ul><li>–module-path 类似于CLASSPATH，JLink到哪里去找modules</li><li>–add-modules 要额外添加的module</li><li>–launcher dkm=dkm/com.dokyme.Main 启动器，或者说是可执行程序。后面跟着的是程序的名字以及入口主类的位置。</li><li>–output 输出路径</li></ul><p>命令执行结束之后就会多出一个dist目录，里面的bin文件夹下存放着可执行文件，这个dist目录大约30MB左右。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/321c50d9e9ddc4d5a698214ac400d572.png" alt> 这个入口文件实际上是一个shell脚本，调用同目录下的java程序载入模块中的主类，执行主类的代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">JLINK_VM_OPTIONS=</span><br><span class="line">DIR=`dirname <span class="variable">$0</span>`</span><br><span class="line"><span class="variable">$DIR</span>/java <span class="variable">$JLINK_VM_OPTIONS</span> -m dkm/com.dokyme.Main <span class="variable">$@</span></span><br></pre></td></tr></table></figure><p>找到一个gradle的plugin，挺有意思： <a href="https://github.com/alkimiapps/gradle-dplink-plugin">gradle-dplink-plugin</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JDK9中的模块化技术使得原本一两百兆的JRE能够被拆分成多个较小的模块，因此如果想要把Java程序打包成可执行程序，并在没有JRE环境的机器上运行，不再需要带上一个庞大的JRE，而只需要额外增加几个JDK中的module。 项目目录结构如下，仅仅是一个很简单的Hello World程序。代码中仅仅使用到了System.out.println这一个JDK中提供的函数。 &lt;img src=&quot;https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/b6fc620903896d3ef034f5bed269fcaa.png&quot; alt&gt; 最重要的是module-info.jar文件，这个文件是module的定义文件，声明了我所编写的这个模块需要依赖哪些模块，以及对外暴露哪些东西。 由于只依赖java.base模块，而这个模块是默认包含的，因此module-info的大括号内可以为空。&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://www.kherrisan.cn/categories/JavaSE/"/>
    
    
      <category term="java" scheme="http://www.kherrisan.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Netty——NioEventLoop(2)</title>
    <link href="http://www.kherrisan.cn/2019/01/05/netty-nioeventloop2/"/>
    <id>http://www.kherrisan.cn/2019/01/05/netty-nioeventloop2/</id>
    <published>2019-01-05T10:36:54.000Z</published>
    <updated>2020-05-03T08:41:45.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Loop过程"><a href="#Loop过程" class="headerlink" title="Loop过程"></a>Loop过程</h1><p><code>NioEventLoop</code>最核心的就是处理事件循环的<code>run</code>方法。这个方法看起来不长，但实际上它承担了最重要的逻辑，并且对很多细节问题做了处理。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) {</span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line"></span><br><span class="line">                <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (wakenUp.get()) {</span><br><span class="line">                        selector.wakeup();</span><br><span class="line">                    }</span><br><span class="line">                    <span class="comment">// fall through</span></span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) {</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                }</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> {</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                } <span class="keyword">finally</span> {</span><br><span class="line">                    <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) {</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) {</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>既然叫eventLoop，那代码的主体部分自然就是一个循环，在每一次循环迭代都根据某些状态做一些针对性工作。 首先是<code>selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())</code>，<code>selectStrategy</code>只有一个实现类：<code>DefaultSelectStrategy</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calculateStrategy</span><span class="params">(IntSupplier selectSupplier, <span class="keyword">boolean</span> hasTasks)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;</span><br><span class="line">}</span><br><span class="line">......</span><br><span class="line">selectSupplier = <span class="keyword">new</span> IntSupplier() {</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">        <span class="keyword">return</span> selectNow();</span><br><span class="line">    }</span><br><span class="line">};</span><br></pre></td></tr></table></figure><ol><li>判断队列中有无任务，如果有，则返回<code>selectNow</code>的结果。</li><li>如果没有，就返回SELECT。</li></ol><p><code>selectNow</code>方法返回的是JDK的select的<code>selectNow</code>方法执行的结果，这个方法执行非阻塞的select，返回<code>SelectionKey</code>的个数，当然如果无事发生的话也会返回0。 <strong><code>selectStrategy</code>中定义了三个常量：SELECT、CONTINUE、BUSY_WAIT，然而后两种并没有在哪里被使用到。</strong>可能是netty是打算先设计好结构，然后再慢慢填坑把。</p><h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>当strategy为SELECT的时候，涉及到<code>NioEventLoop</code>的<code>select</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">(<span class="keyword">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    Selector selector = <span class="keyword">this</span>.selector;</span><br><span class="line">        <span class="keyword">int</span> selectCnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTimeNanos = System.nanoTime();</span><br><span class="line">        <span class="keyword">long</span> selectDeadLineNanos = currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) {</span><br><span class="line">            <span class="keyword">long</span> timeoutMillis = (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis <= <span class="number">0</span>) {</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) {</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() && wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> selectedKeys = selector.select(timeoutMillis);</span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) {</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) {</span><br><span class="line">                    ......</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> time = System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) >= currentTimeNanos) {</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD > <span class="number">0</span> &&</span><br><span class="line">                    selectCnt >= SELECTOR_AUTO_REBUILD_THRESHOLD) {</span><br><span class="line">                rebuildSelector();</span><br><span class="line">                selector = <span class="keyword">this</span>.selector;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        }</span><br><span class="line">        ......</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">delayNanos</span><span class="params">(<span class="keyword">long</span> currentTimeNanos)</span> </span>{</span><br><span class="line">    ScheduledFutureTask<?> scheduledTask = peekScheduledTask();</span><br><span class="line">    <span class="keyword">if</span> (scheduledTask == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> SCHEDULE_PURGE_INTERVAL;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scheduledTask.delayNanos(currentTimeNanos);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>select</code>方法在循环中尝试根据时间限制来进行阻塞或者非阻塞的select操作。这里的时间限制就是<code>selectDeadLineNanos</code>，他根据下一个任务的时间限制给出这次阻塞select最迟必须结束的时间。如果没有下一个任务，就给出长达SCHEDULE_PURGE_INTERVAL的时间，当然在这段时间内如果有任务到来还是会按照任务的deadline时间做判断。</p><ol><li>如果还有不到500ms就要到ddl了，就结束循环，不过如果还没有执行过阻塞select，为了不破坏<code>select</code>方法的语义，可以先selectNow一次。</li><li>如果任务队列里有任务了，尝试将这个<code>NioEventLoop</code>设置为唤醒，如果唤醒成功，selectNow一次并结束。</li><li>通过selector执行阻塞的select操作，可以阻塞到ddl的前500ms，即在ddl之前预留500ms，说不定要做别的事情。记录阻塞select次数。</li><li>如果阻塞select操作真的返回了几个事件，结束循环。</li><li>如果用户（就是除了对象本身之外的其他人）唤醒了它，结束循环。</li><li>如果任务队列有任务了，或者有调度任务了，结束循环。</li><li>如果线程被中断了，结束循环。</li><li>如果阻塞select次数超过了一个阈值，说明selector出bug了，重建selector，selectNow一次，结束循环。</li></ol><p>在循环体开头的switch可以这么解释：</p><ol><li>如果任务队列里有任务，就让<code>selector</code>selectNow一次，非阻塞地看看有没有什么事件发生，不管事件是0个还是几个，继续执行switch下面的代码。</li><li>如果没有任务，就考虑执行一段时间阻塞的select操作。</li></ol><p>结束了switch，该处理事件和执行任务了。这里netty又来骚操作了——<code>ioRatio</code>，这个变量代表两个过程——IO和运行任务分别所占时间比例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ioRatio == <span class="number">100</span>) {</span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    runAllTasks();</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">    processSelectedKeys();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>判断方法很简单，如果<code>ioRatio</code>是100，就运行所有的任务；如果不是100，比如说是20，那么记录下IO所话的时间<code>ioTime</code>，然后限定运行任务的时间为<code>ioTime*(100-20)/20</code>，也就是4倍<code>ioTime</code>。</p><h2 id="processSelectedKeys"><a href="#processSelectedKeys" class="headerlink" title="processSelectedKeys"></a>processSelectedKeys</h2><p>既然select操作检测到了IO事件，那么就要处理对应的key，这个key和JavaNIO中是SelectionKey是一回事。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) {</span><br><span class="line">    processSelectedKeysOptimized();</span><br><span class="line">} <span class="keyword">else</span> {</span><br><span class="line">    processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>netty提供了两种处理selectionKey的方法——plain和optimized。<code>NioEventLoop</code>对象维护了一个<code>SelectedSelectionKeySet</code>对象，这个对象管理了一个selectionKey的集合。至于为什么不用Java原生的Set容器，应该还是出于效率上的考虑（TreeSet和HashSet在某些场景下都不如数组来的快）。 <code>SelectedSelectionKeySet</code>使用一个数组来作为set的底层实现，初始长度为1024，add操作向数组索引为size的位置插入元素，如果长度不够就扩容一倍，没有缩容的情况，没有remove操作，提供迭代器访问形式。 先看<code>processSelectedKeysOptimized</code>到底是怎么optimize的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < selectedKeys.size; ++i) {</span><br><span class="line">        <span class="keyword">final</span> SelectionKey k = selectedKeys.keys[i];</span><br><span class="line">        selectedKeys.keys[i] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">final</span> Object a = k.attachment();</span><br><span class="line">        <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) {</span><br><span class="line">            processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">        } <span class="keyword">else</span> {</span><br><span class="line">            processSelectedKey(k, (NioTask<SelectableChannel>)task);</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> (needsToSelectAgain) {</span><br><span class="line">            ......</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>遍历set中的每一个selectionKey，取出attach在它上面的对象，有可能是<code>AbstractNioChannel</code>，也有可能是<code>NioTask</code>。 <strong>这里可以思考一下：SelectionKey上的attachment是什么时候加上去的？</strong> 在<code>AbstractNioChannel</code>中的<code>doRegister</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p><code>AbstractNioChannel</code>被attach到了<code>SelectionKey</code>上面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>{</span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">        <span class="keyword">if</span> ((readyOps & SelectionKey.OP_CONNECT) != <span class="number">0</span>) {</span><br><span class="line">            k.interestOps(k.interestOps() & ~SelectionKey.OP_CONNECT);</span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((readyOps & SelectionKey.OP_WRITE) != <span class="number">0</span>) {</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">if</span> ((readyOps & (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) {</span><br><span class="line">            unsafe.read();</span><br><span class="line">        }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>思路很清晰，就是根据<code>readyOps</code>的不同的值，采取不同的行为。 <code>processSelectedKeysPlain</code>实际上类似，区别主要在于它使用Java自带的Set存放SelectionKey。</p><h2 id="runAllTasks"><a href="#runAllTasks" class="headerlink" title="runAllTasks"></a>runAllTasks</h2><p><code>runAllTasks</code>有两种，带时间限的和不带时间限的。不带时间限则执行所有任务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> {</span><br><span class="line">    fetchedAll = fetchFromScheduledTaskQueue();</span><br><span class="line">    <span class="keyword">if</span> (runAllTasksFrom(taskQueue)) {</span><br><span class="line">        ranAtLeastOne = <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">} <span class="keyword">while</span> (!fetchedAll); <span class="comment">// keep on processing until we fetched all scheduled tasks.</span></span><br></pre></td></tr></table></figure><p>首先从<code>ScheduledTaskQueue</code>中取出任务，存放到<code>taskQueue</code>中，直到所有<code>ScheduledTaskQueue</code>被取空，或者<code>taskQueue</code>已满。 然后逐个执行<code>taskQueue</code>中的所有任务，直到<code>taskQueue</code>为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) {</span><br><span class="line">    safeExecute(task);</span><br><span class="line">    task = pollTaskFrom(taskQueue);</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>引用闪电侠博客中的一张图来概括loop的过程。 <img src="https://upload-images.jianshu.io/upload_images/1357217-67ed6d1e8070426f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000/format/webp" alt></p><h1 id="wakenUp"><a href="#wakenUp" class="headerlink" title="wakenUp"></a>wakenUp</h1><p>参考：<a href="https://wenku.baidu.com/view/c75d218c804d2b160a4ec04c.html">Netty原子wakeup作用分析</a>，虽然这篇文章已经严重过期了。 在<code>NioEventLoop</code>对象中，有一个<code>AtomicBoolean</code>——<code>wakenUp</code>，在<code>run</code>方法及其调用的其他方法中多次见到了对该变量的判断及CAS（Compare and Set）操作，之前一直忽略了这个变量的作用。</p><blockquote><p>Boolean that controls determines if a blocked Selector.select should break out of its selection process. In our case we use a timeout for the select method and the select method will block for that time unless waken up.</p></blockquote><p>字面意思为：决定<code>Selector.select</code>阻塞调用是否要中断select过程的一个Boolean，即是否应该通过<code>select.wakeUp()</code>唤醒正在阻塞的select操作。 <strong>主要目的是防止<code>selector.wakeUp()</code>被重复调用，因为<code>selector.wakeUp()</code>操作的开销还是不小的。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">wakeup</span><span class="params">(<span class="keyword">boolean</span> inEventLoop)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop && wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里有个问题：<code>NioEventLoop</code>是单线程的代码逻辑，怎么会出现在selector阻塞的同时唤醒他呢？我认为问题出在selector可能不是单线程独享的，即不是每一个<code>NioEventLoop</code>都有一个独立的<code>selector</code>。此外，通过<code>NioEventLoop.execute</code>执行<code>Runnable</code>是串行的，但调用<code>NioEventLoop</code>的其他方法时还是会出现多线程并发的情况。 在switch语句块的SELECT分支中，会首先设置<code>wakenUp</code>为false，相当于每次循环时都给<code>wakenUp</code>变量设个初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">    select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br></pre></td></tr></table></figure><p>在<code>select()</code>方法中，有两处对<code>wakenUp</code>的值做了判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>{</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (hasTasks() && wakenUp.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) {</span><br><span class="line">        selector.selectNow();</span><br><span class="line">        selectCnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line">    ......</span><br><span class="line">    selector.select(timeoutMillis);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (wakenUp.get()) {</span><br><span class="line">    selector.wakeup();</span><br><span class="line">}</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Loop过程&quot;&gt;&lt;a href=&quot;#Loop过程&quot; class=&quot;headerlink&quot; title=&quot;Loop过程&quot;&gt;&lt;/a&gt;Loop过程&lt;/h1&gt;&lt;p&gt;&lt;code&gt;NioEventLoop&lt;/code&gt;最核心的就是处理事件循环的&lt;code&gt;run&lt;/code&gt;方法。这个方法看起来不长，但实际上它承担了最重要的逻辑，并且对很多细节问题做了处理。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="http://www.kherrisan.cn/categories/Netty/"/>
    
    
      <category term="java" scheme="http://www.kherrisan.cn/tags/java/"/>
    
      <category term="Netty" scheme="http://www.kherrisan.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty——NioEventLoop(1)</title>
    <link href="http://www.kherrisan.cn/2018/12/24/netty-nioeventloop/"/>
    <id>http://www.kherrisan.cn/2018/12/24/netty-nioeventloop/</id>
    <published>2018-12-24T20:41:23.000Z</published>
    <updated>2020-05-03T08:41:45.626Z</updated>
    
    <content type="html"><![CDATA[<p>作为Netty中最核心的概念之一，<code>NioEventLoop</code>作为线程实体承载Netty中几乎所有代码的运行、所有事件的检测和触发。<code>EventLoop</code>这个单词并不陌生。在很多的图形用户界面（GUI）程序中，都会使用较少的数个线程来运行代码，以应对用户操作事件。 由于Netty的线程模型基于Java的<strong>NIO</strong>，而NIO又是通过<strong>IO多路复用</strong>实现的。IO多路复用是底层技术，在其之上则是负责管理多路IO的线程模型。Reactor模式就是一种经典的多线程IO设计模型。 </p><a id="more"></a><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/f1e818b190a1ab88c077a337c471f8f3.png" alt> 上面的第一张图是多线程IO模型，第二张图是单线程NIO模型，第三张图是Reactor线程模型。第一和第二张图的区别主要在于线程是否复用，第二和第三张图的区别在于第二张图使用单线程（进程）处理读写事件而图三将对同一台远程主机的操作聚合到一个Handler里面，由Reactor负责派发事件给Handler执行。 当然，Handler中代码的执行也是需要线程的，这时就可以考虑线程的复用，即通过线程池管理线程。而Acceptor也可以进行多线程并发，也可以使用线程池。</p><h1 id="EventLoop类体系"><a href="#EventLoop类体系" class="headerlink" title="EventLoop类体系"></a>EventLoop类体系</h1><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/31af451f0f108a2f460d9f1061b87ac0.png" alt> 图中白框框处的是JDK中自带的类。显然Netty也是利用了JDK中的接口来表达类的语义。</p><ol><li><code>Executor</code>表示任务的执行者，只有一个方法<code>execute()</code>，和<code>Runnable</code>的概念有点类似，但实际上是caller和callee的关系。</li><li><code>ExecutorService</code>表示提供执行功能的服务方，所有的线程池都是<code>ExecutorService</code>的子类，这个接口定义了和executor相关的一些方法，如<code>execute</code>,<code>submit</code>等。</li><li><code>EventExecutorGroup</code>表示基于事件的执行者集合，它继承了<code>Iterable</code>，说明他可以迭代，且每个元素都是<code>EventExecutor</code>。同时它继承了<code>ScheduledExecutorService</code>接口，表明他具有调度定时任务的功能。</li><li><code>EventExecutor</code>表示任务的执行者。</li><li><code>EventLoopGroup</code>表示<code>EventLoop</code>的集合，即线程的集合，这个接口的主要功能一个是遍历<code>EventLoop</code>，另一个是允许将<code>channel</code>注册到某个<code>EventLoop</code>上。</li><li><code>EventLoop</code>负责处理各个<code>channel</code>的任务，一般一个<code>EventLoop</code>会对应多个<code>channel</code>。此接口本身并没有提供什么有趣的方法。</li></ol><h1 id="第一个NioEventLoop"><a href="#第一个NioEventLoop" class="headerlink" title="第一个NioEventLoop"></a>第一个NioEventLoop</h1><p>不妨探索一下Netty启动时第一个<code>NioEventLoop</code>是何时何地启动的，以典型的启动代码为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>忽略重载的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, <span class="keyword">final</span> SelectorProvider selectorProvider,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">final</span> SelectStrategyFactory selectStrategyFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(nThreads, executor, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里调用了父类的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">static</span> {</span><br><span class="line">            DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(</span><br><span class="line">            <span class="string">"io.netty.eventLoopThreads"</span>, NettyRuntime.availableProcessors() * <span class="number">2</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>{</span><br><span class="line">        <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>NioEventLoopGroup</code>是一个<code>MultiThreadEventLoopGroup</code>，即多线程事件循环组，最关键的是多线程的，这里既可以指多个线程，也可以看做是多个<code>EventLoop</code>组成的group。<strong>线程个数取决于最开始传入的整数，如果这个数是0，则会取一个默认值——处理器个数x2。</strong> 继续跟踪这个类的重载的及其父类的构造函数，直到构造函数中有明显的代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor,</span></span></span><br><span class="line"><span class="function"><span class="params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>{</span><br><span class="line">    <span class="keyword">if</span> (executor == <span class="keyword">null</span>) {</span><br><span class="line">        executor = <span class="keyword">new</span> ThreadPerTaskExecutor(newDefaultThreadFactory());</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    children = <span class="keyword">new</span> EventExecutor[nThreads];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < nThreads; i ++) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            children[i] = newChild(executor, args);</span><br><span class="line">            success = <span class="keyword">true</span>;</span><br><span class="line">        } <span class="keyword">finally</span> {</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j < i; j ++)</span><br><span class="line">                    children[j].shutdownGracefully();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    chooser = chooserFactory.newChooser(children);</span><br><span class="line">    <span class="keyword">final</span> FutureListener<Object> terminationListener = ......;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (EventExecutor e: children) {</span><br><span class="line">        e.terminationFuture().addListener(terminationListener);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在<code>NioEventLoopGroup</code>初始化时，参数<code>executor</code>为null，于是会首先创建一个<code>ThreadPerTaskExecutor</code>（顾名思义，为每个任务取得一个线程来执行它的Executor，至于如何取得，是直接创建新线程还是复用线程，要看具体情况）。 <code>ThreadPerTaskExecutor</code>的<code>execute</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>{</span><br><span class="line">    threadFactory.newThread(command).start();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在这里，<code>threadFactory</code>是一个<code>DefaultThreadFactory</code>对象，它提供线程的方式由<code>newThread</code>方法决定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>{</span><br><span class="line">    Thread t = newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());</span><br><span class="line">        <span class="keyword">if</span> (t.isDaemon() != daemon) {</span><br><span class="line">            t.setDaemon(daemon);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (t.getPriority() != priority) {</span><br><span class="line">            t.setPriority(priority);</span><br><span class="line">        }</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>显然，这里的<code>ThreadPerTaskExecutor</code>会将收到的每个task放到一个新创建的线程里运行。 回到构造函数，接下来程序开辟了一个数组用于存放所有的executor。<code>EchoServer</code>中nThread取1，自然就开辟长度为1的数组。 <code>newChild</code>在<code>MultithreadEventExecutorGroup</code>是一个抽象方法，具体如何创建子executor取决于其子类的实现。<code>NioEventLoopGroup</code>是这么实现它的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider) args[<span class="number">0</span>],</span><br><span class="line">        ((SelectStrategyFactory) args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="number">2</span>]);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>直接new了一个<code>NioEventLoop</code>，并且把<code>executor</code>作为构造函数的参数传进了<code>NioEventLoop</code>。不过<code>executor</code>并不是由<code>NioEventLoop</code>使用，而是由其父类的父类——<code>SingleThreadEventExecutor</code>作为属性之一进行维护。<code>SingleThreadEventExecutor</code>作为<code>executor</code>的维护者，在它的代码中也只有一处地方用到了<code>executor</code>，就在<code>doStartThread</code>函数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>{</span><br><span class="line">    executor.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                SingleThreadEventExecutor.<span class="keyword">this</span>.run();</span><br><span class="line">            } <span class="keyword">catch</span> (Throwable t) {</span><br><span class="line">                ......</span><br><span class="line">            } <span class="keyword">finally</span> {</span><br><span class="line">                ......</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>而这个<code>doStartThread</code>方法也不是<code>SingleThreadEventExecutor</code>一诞生就起作用的，在<code>SingleThreadEventExecutor</code>的<code>execute</code>方法中调用了该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) {</span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) {</span><br><span class="line">            ......</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>重新审视<code>SingleThreadEventExecutor</code>，他提供了一个<code>execute</code>方法，当有人调用了该对象的<code>execute</code>方法时，会把要运行的任务加入到一个任务队列中（通过<code>addTask</code>方法，这个方法不看我们都能猜到是什么意思的）。如果是第一次execute，就在修改队列之后通过<code>SingleThreadEventExecutor</code>自带的<code>executor</code>启动一个线程，这个线程执行一个抽象的<code>run</code>方法，在<code>NioEventLoop</code>中对该方法给出了实现。 这里遇到了三种executor——<code>ThreadPerTaskExecutor</code>和<code>SingleThreadEventExecutor</code>，前者给每个任务（也就是<code>Runnable</code>）分配一个线程来执行，后者则只使用一个线程（只做一次<code>startThread</code>，那肯定只有一个线程了），<code>NioEventLoop</code>则也在其整个生命周期中只使用一个线程，此外它通过轮训来从队列中取任务。 <strong>那么问题来了，<code>SingleThreadEventExecutor</code>为什么要用<code>ThreadPerTaskExecutor</code>启动线程呢，二者看似是平级的概念，为什么却采用了包含关系？</strong> 会到负责启动多个<code>SingleThreadEventExecutor</code>的<code>MultithreadEventExecutorGroup</code>，接下来通过<code>chooserFactory</code>得到了一个<code>chooser</code>，这个对象的作用是根据特定的策略选择多个<code>executor</code>中的一个，即一个选择器。 <strong>这里不禁想起了在负载均衡中应该也有一个这样的<code>chooser</code>，只是不知道这样的<code>chooser</code>应该处于怎样的层级，来收集做出选择所需要的信息。</strong> 回到最初的问题——第一个<code>NioEventLoop</code>是何时启动的？到目前为止，第一个<code>NioEventLoop</code>已经诞生了，但他的<code>execute</code>方法还没有被任何人调用，因此他还没有启动自己的轮训线程。也就是说，应该是在另外的某一个犄角旮旯里，某行代码调用了<code>execute</code>，启动了第一个<code>NioEventLoop</code>的线程。 启动<code>EchoServer</code>的代码就那么多，不是初始化<code>EventLoopGroup</code>就是配置<code>Bootstrap</code>，最后就是<code>bind</code>。我认为在<code>bind</code>中可能性最大。 在前一篇文章中曾经分析过服务端启动的流程。这里稍微略过一些细节。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在<code>AbstractBootstrap</code>的<code>doBind</code>方法中，发现了<code>ChannelFuture</code>的踪迹。Future是一种返回异步结果的常见形式，出现了<code>ChannelFuture</code>说明其中肯定有某个函数是通过另一个线程执行操作，然后异步返回运行结果的。继续紧跟这个Future。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里的<code>group()</code>返回了一个<code>NioEventLoopGroup</code>。我有一个疑问： <strong>这个<code>NioEvnetLoopGroup</code>是Boss还是Worker呢？</strong> 这里我用了一个土办法，在调试模式下加断点，看对象的ID。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/d7902ca4f0352876f72b9ffc01c72830.png" alt> 答案了然了，这是一个Boss。继续跟踪。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在<code>SingleThreadEventLoop</code>中，Future逐渐浮出水面——他是作为一个Promise被创建出来的。但这里只是创建，并没有修改Future的状态，也没有在Future中填充异步运行的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) {</span><br><span class="line">        register0(promise);</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    register0(promise);</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在<code>AbstractChannel</code>中出现了一个<code>eventLoop</code>，这个<code>eventLoop</code>是不是就是通过<code>newChild</code>得到的<code>NioEventLoop</code>呢？再次祭出比对ID大法。 这里我就不截图了，结果是这里的<code>eventLoop</code>是作为boss的<code>NioEventLoopGroup</code>制造出来的。 这里代码会进入else分支，即<code>eventLoop.execute</code>，那么第一个<code>NioEventLoop</code>就会将这个<code>Runnable</code>加到自己的任务队列中，接着通过<code>ThreadPerTaskExecutor.execute</code>运行自己的<code>run</code>方法，在<code>run</code>方法中轮训任务队列，运行<code>Runnable</code>。</p><h1 id="eventLoop-inEventLoop"><a href="#eventLoop-inEventLoop" class="headerlink" title="eventLoop.inEventLoop"></a>eventLoop.inEventLoop</h1><p>我认为这个方法是一个十分关键的方法，虽然实现逻辑很简单，<strong>但他却很清晰地诠释了netty设计思路中对象和线程之间的关系，即executor和thread这两大概念之间的关系。</strong> netty把这个方法的定义放在了<code>AbstractEventExecutor</code>类中。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/305bf4c6bc929c927ede4eecb54f2d68.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> inEventLoop(Thread.currentThread());</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在<code>AbstractEventExecutor</code>中，<code>inEventLoop</code>表示在当前这个线程的<code>EventLoop</code>，由于<code>EventLoop</code>是单线程的（它是<code>SingleThreadEventExecutor</code>的子类），一个<code>EventLoop</code>对象<code>run</code>方法的代码只会运行在一个线程中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inEventLoop</span><span class="params">(Thread thread)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> thread == <span class="keyword">this</span>.thread;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>在<code>SingleThreadEventExecutor</code>中，<code>inEventLoop</code>表示传入参数的thread对象和与对象自身绑定的thread对象是同一个对象。 也就是说，一个<code>SingleThreadEventLoop</code>对象会和一个线程绑定，当想要通过这个对象执行某些方法的时候，可以先通过<code>inEventLoop()</code>方法判断，当前线程是不是和这个eventLoop绑定的线程，继而针对不同情况进行区分处理。如：如果当前线程不是eventLoop绑定的那个线程，就通过<code>execute</code>方法把任务加入到任务队列中；如果就是当前线程，那就直接运行代码。这样可以避免产生多线程操作同一个对象所带来的同步问题。</p><h1 id="重新梳理Bootstrap"><a href="#重新梳理Bootstrap" class="headerlink" title="重新梳理Bootstrap"></a>重新梳理Bootstrap</h1><p>结合<code>NioEventLoop</code>的初始化过程，重新梳理netty程序的启动流程。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/44c84ddc625008b39ff4bb98e6d4fd05.png" alt></p><ol><li>创建<code>NioEventLoopGroup</code>，包含多个<code>NioEventLoop</code>，个数视情况而定。每个<code>NioEventLoop</code>的<code>run</code>方法还没有开始运行。</li><li><code>Bootstrap</code>在<code>bind</code>的时候，通过反射创建<code>NioServerSocketChannel</code>对象。</li><li>初始化<code>NioServerSocketChannel</code>上面的attribute和option。</li><li><code>NioEventLoopGroup</code>选出下一个<code>NioEventLoop</code>，让channel注册到它上面。</li><li>在选中的<code>NioEventLoop</code>的线程上，注册interestOps和attachment到selector上。</li><li>在channel的eventloop线程上，通过<code>headContext</code>绑定到指定端口上。</li></ol><p><strong>NioEventLoop</strong>的核心——loop的梳理，见下一篇。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;作为Netty中最核心的概念之一，&lt;code&gt;NioEventLoop&lt;/code&gt;作为线程实体承载Netty中几乎所有代码的运行、所有事件的检测和触发。&lt;code&gt;EventLoop&lt;/code&gt;这个单词并不陌生。在很多的图形用户界面（GUI）程序中，都会使用较少的数个线程来运行代码，以应对用户操作事件。 由于Netty的线程模型基于Java的&lt;strong&gt;NIO&lt;/strong&gt;，而NIO又是通过&lt;strong&gt;IO多路复用&lt;/strong&gt;实现的。IO多路复用是底层技术，在其之上则是负责管理多路IO的线程模型。Reactor模式就是一种经典的多线程IO设计模型。 &lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="http://www.kherrisan.cn/categories/Netty/"/>
    
    
      <category term="java" scheme="http://www.kherrisan.cn/tags/java/"/>
    
      <category term="Netty" scheme="http://www.kherrisan.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>K2-PandoraBox-IPV6（教育网）配置过程</title>
    <link href="http://www.kherrisan.cn/2018/11/25/k2-pandorabox-ipv6/"/>
    <id>http://www.kherrisan.cn/2018/11/25/k2-pandorabox-ipv6/</id>
    <published>2018-11-25T18:06:38.000Z</published>
    <updated>2020-05-03T08:41:45.626Z</updated>
    
    <content type="html"><![CDATA[<p><strong>坐标：东南大学九龙湖校区梅园4C某宿舍</strong> 昨晚向某个同学要了一台斐讯K2路由器，本想替换掉宿舍的TP-Link来提供5GHz频段的Wifi，因为2.4GHz频段的Wifi对我MacbookPro2018的USB-HUB以及蓝牙干扰太过于严重。忽然想把宿舍隔壁床位的IPV6网口利用起来。 之前尝试过将PC网口与IPV6网口直连上网，体会到了飞一般的网速，举个例子：下载一个ubuntu-desktop的镜像，大概只需要两分多钟就可以下载完毕。</p><a id="more"></a><h1 id="K2固件相关工作"><a href="#K2固件相关工作" class="headerlink" title="K2固件相关工作"></a>K2固件相关工作</h1><ol><li>刷<strong>breed</strong>不死鸟固件。</li><li>刷<strong>PandoraBox</strong>固件。</li></ol><h2 id="联网"><a href="#联网" class="headerlink" title="联网"></a>联网</h2><p>在浏览器中打开<code>192.168.1.1</code>，输入默认密码<code>admin</code>，进入<code>PandoraBox</code>管理页面。 由于我此时已经将<code>IPV6</code>网口与路由去<code>WAN</code>口相连，因此在网络-接口界面可以看到<code>WAN6</code>口已经通过<code>DHCP</code>从上游路由器（DHCP服务器）得到了IPV6网址。 如果插入了<code>IPV6</code>网线，但页面上没有<code>IPV6</code>地址，可以尝试点击“连接”按钮重新连接上游路由器，并等待1分钟左右，一般就可以获得<code>IPV6</code>地址了。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2018-11-24_13-35-37.png" alt></p><h2 id="下载所需程序"><a href="#下载所需程序" class="headerlink" title="下载所需程序"></a>下载所需程序</h2><p>打开一个控制台，通过ssh连到路由器上，<strong>密码默认为admin</strong>：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh <span class="symbol">root@</span><span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2018-11-24_13-37-31.png" alt> 路由器的操作系统也是Linux的一种，因此熟悉PC端Linux操作的人应该不会有太大困难。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">opkg update</span><br><span class="line"><span class="built_in">..</span><span class="built_in">..</span><span class="built_in">..</span></span><br><span class="line">opkg install ip6tables kmod-ipt-nat6</span><br></pre></td></tr></table></figure><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/Snipaste_2018-11-24_13-38-30.png" alt> 安装2个程序，装好了之后回到浏览器。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>进入网络-接口-LAN-DHCP服务器页面，勾选<strong>总是通告默认路由</strong>。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/3adea32eb5cb208d4e481e3321a0b88d.png" alt> 进入网络-防火墙-自定义规则页面，添加一条规则，并<strong>重启防火墙</strong>。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip6tables -t<span class="built_in"> nat </span>-A POSTROUTING -o eth0.2 -j MASQUERADE</span><br></pre></td></tr></table></figure><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/2ade23d4f609146101a4df4396b8621f.png" alt> 回到路由器终端，找出IPV6的默认路由网关地址，然后添加一条新的路由规则：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ip -6<span class="built_in"> route </span>| grep default</span><br><span class="line">假设输出的地址为xxxx::xxxx</span><br><span class="line">route -A inet6 <span class="builtin-name">add</span><span class="built_in"> default </span>gw xxxx::xxxx dev eth0.2</span><br></pre></td></tr></table></figure><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/339f07f8fd170d0765c79ed2027d2105.png" alt> 最后，重启一下相关服务。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/init.d<span class="built_in">/firewall </span>restart</span><br><span class="line">/etc/init.d<span class="built_in">/network </span>restart</span><br></pre></td></tr></table></figure><h2 id="测试连通性"><a href="#测试连通性" class="headerlink" title="测试连通性"></a>测试连通性</h2><p>重启结束之后，PC就可以<code>ping</code>通谷歌了，如果<code>ping</code>不通，可以重连一下路由器的<code>Wifi</code>。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/259f944fc4663699a06f4f8ef77f6022.png" alt></p><h2 id="打开网页"><a href="#打开网页" class="headerlink" title="打开网页"></a>打开网页</h2><p>离终点只有一步之遥了：由于<strong>chrome</strong>浏览器采用的策略是IPV6和IPV4共存，解析网址的<code>IPV6</code>和<code>IPV4</code>地址，然后优先与<code>IPV6</code>地址发起连接，当连接的时间超过300ms（具体数值不清楚）时，说明链路中的<code>IPV6</code>机制有问题，就会切换到<code>IPV4</code>地址发起<code>TCP</code>连接，最后发送<code>HTTP</code>请求报文。 这样的流程对于国内想要通过<code>IPV6</code>翻墙的用户而言是不合适的，因为连接远程主机的延迟一般会比较高，导致链路正常联通的<code>IPV6</code>链路被浏览器舍弃，转而尝试去访问无法连接的<code>IPV4</code>地址。 而我们希望的理想的过程是，浏览器先解析IPV6地址，只要<code>IPV6</code>地址存在，就直接去连接该地址，不要去管<code>IPV4</code>地址是多少。或者说串行地去请求做<code>IPV6</code>和<code>IPV4</code>地址的<code>DNS</code>解析操作。在<code>DNS</code>协议中，<code>IPV6</code>和<code>IPV4</code>对应报文头部的<code>type</code>值分别为<code>AAAA</code>和<code>A</code>。此外，需要在本机配置<code>DNS</code>服务器地址为本机地址。 我在Github上找到了这么一个好东西： <a href="https://github.com/adamyi/v6dns">adamyi/v6dns</a> 这是一个<code>DNS</code>服务的中继程序，会在某个端口上监听所有<code>DNS</code>报文，并按照下面的逻辑运行： <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/fafa577fd8ba1491f759bc03e039eacb.png" alt> 为了解决<code>IPV4/6</code>优先级的问题，可以这么做：在本地运行v6dns程序，监听本机的53端口，并设置<code>DNS</code>查询服务器为某个远程的<code>DNS</code>服务器地址。这样，如果能够查询到某个网站的<code>IPV6</code>地址，那就直接发起连接，如果查不到，就再查询其<code>IPV4</code>地址。</p><h2 id="最终总结"><a href="#最终总结" class="headerlink" title="最终总结"></a>最终总结</h2><p>本文介绍了在教育网环境下使用K2的PandoraBox固件进行配置最终访问<code>IPV6</code>网站的过程，其中最核心的步骤就是配置<code>NAT6</code>，<code>NAT6</code>是基于<code>IPV6</code>的网络地址转换，目的是将上游<code>DHCP6</code>分配的一个<code>IPV6</code>地址转换成内网的多个地址分配给多个主机。 最终测试的效果不佳，在Youtube上看视频时常常出现卡顿的现象，记忆中原来看视频能够达到4K画质，并且帧率为60fps的网速水准。推测原因如下：</p><ol><li>K2路由器不够稳定。</li><li>PandoraBox固件或NAT6机制不够成熟。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;坐标：东南大学九龙湖校区梅园4C某宿舍&lt;/strong&gt; 昨晚向某个同学要了一台斐讯K2路由器，本想替换掉宿舍的TP-Link来提供5GHz频段的Wifi，因为2.4GHz频段的Wifi对我MacbookPro2018的USB-HUB以及蓝牙干扰太过于严重。忽然想把宿舍隔壁床位的IPV6网口利用起来。 之前尝试过将PC网口与IPV6网口直连上网，体会到了飞一般的网速，举个例子：下载一个ubuntu-desktop的镜像，大概只需要两分多钟就可以下载完毕。&lt;/p&gt;
    
    </summary>
    
    
      <category term="未分类" scheme="http://www.kherrisan.cn/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>Netty——下载、编译、调试源码</title>
    <link href="http://www.kherrisan.cn/2018/11/15/netty/"/>
    <id>http://www.kherrisan.cn/2018/11/15/netty/</id>
    <published>2018-11-15T20:39:40.000Z</published>
    <updated>2020-05-03T08:41:45.626Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Intellij，启动！"><a href="#Intellij，启动！" class="headerlink" title="Intellij，启动！"></a>Intellij，启动！</h1><h2 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h2><p><a href="https://www.jianshu.com/p/9160684f134b">Netty分享之动态生成重复性的代码</a></p><a id="more"></a><h2 id="完整过程"><a href="#完整过程" class="headerlink" title="完整过程"></a>完整过程</h2><p>我选择直接通过Intellij来clone Netty在Github上的源码，这样就不需要再另外起一个控制台了。Github地址如下： <a href="https://github.com/netty/netty.git">https://github.com/netty/netty.git</a> <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/fa1ea85ae614f8195aa96fe0f42e82df.png" alt> 好了，现在就可以运行example中的程序了，直接点Intellij的运行就行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Intellij，启动！&quot;&gt;&lt;a href=&quot;#Intellij，启动！&quot; class=&quot;headerlink&quot; title=&quot;Intellij，启动！&quot;&gt;&lt;/a&gt;Intellij，启动！&lt;/h1&gt;&lt;h2 id=&quot;参考资料：&quot;&gt;&lt;a href=&quot;#参考资料：&quot; class=&quot;headerlink&quot; title=&quot;参考资料：&quot;&gt;&lt;/a&gt;参考资料：&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/9160684f134b&quot;&gt;Netty分享之动态生成重复性的代码&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="http://www.kherrisan.cn/categories/Netty/"/>
    
    
      <category term="java" scheme="http://www.kherrisan.cn/tags/java/"/>
    
      <category term="Netty" scheme="http://www.kherrisan.cn/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Netty——Bootstrap</title>
    <link href="http://www.kherrisan.cn/2018/11/14/netty-bootstrap/"/>
    <id>http://www.kherrisan.cn/2018/11/14/netty-bootstrap/</id>
    <published>2018-11-14T20:24:36.000Z</published>
    <updated>2020-05-03T08:41:45.626Z</updated>
    
    <content type="html"><![CDATA[<p>以netty-example中的Echo（Server）为例，分析Netty源码的结构与运行过程。 跳过SSL相关的部分。从下面这一行代码开始：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture f = b.bind(PORT).sync();</span><br></pre></td></tr></table></figure><a id="more"></a><p><code>sync</code>方法的功能是同步地等待该操作结束，因此对于server启动监听没有实质性的作用，这里可以忽略他。 首先进入到<code>bootstrap.bind</code>方法中，这个方法由<code>AbstractBootstrap</code>负责实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new {<span class="doctag">@link</span> Channel} and bind it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(<span class="keyword">int</span> inetPort)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> bind(<span class="keyword">new</span> InetSocketAddress(inetPort));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>再进入到<code>bind</code>方法中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new {<span class="doctag">@link</span> Channel} and bind it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress)</span> </span>{</span><br><span class="line">    validate();</span><br><span class="line">    <span class="keyword">if</span> (localAddress == <span class="keyword">null</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"localAddress"</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> doBind(localAddress);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>bind</code>方法做了两件事：1.做一些校验工作；2.调用<code>doBind</code>方法进行真正的监听地址绑定。校验操作一般无足轻重，因此不妨直接进入<code>doBind</code>方法中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>{</span><br><span class="line">    <span class="keyword">final</span> ChannelFuture regFuture = initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) {</span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        <span class="comment">// Registration future is almost always fulfilled already, but just in case it's not.</span></span><br><span class="line">        <span class="keyword">final</span> PendingRegistrationPromise promise = <span class="keyword">new</span> PendingRegistrationPromise(channel);</span><br><span class="line">        regFuture.addListener({</span><br><span class="line">                doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        });</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><strong>上面的代码并不完整，删除了一些细枝末节，因为目前阅读源码的目的是尽快尽可能完整地理清楚程序脉络，因此我删除了自认为对于程序总体认识没有太大帮助的代码。</strong> <code>doBind</code>方法主要做了两件事：</p><ol><li><code>initAndRegiter</code></li><li><code>doBind0</code></li></ol><p>暂时不知道这两个方法各自起了怎样的作用，一个一个来看。</p><h1 id="initAndRegister"><a href="#initAndRegister" class="headerlink" title="initAndRegister"></a>initAndRegister</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">    channel = channelFactory.newChannel();</span><br><span class="line">    init(channel);</span><br><span class="line">    ......</span><br><span class="line">    ChannelFuture regFuture = config().group().register(channel);</span><br><span class="line">    ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>initAndRegister</code>方法所做的工作可以大致分为三块：</p><ol><li>调用<code>channelFactory</code>实例化<code>channel</code>；</li><li>初始化<code>channel</code>；</li><li>将<code>channel</code>注册到<code>group</code>返回的对象上去。</li></ol><h2 id="实例化Channel"><a href="#实例化Channel" class="headerlink" title="实例化Channel"></a>实例化Channel</h2><p><strong>Netty和NIO都有一个叫做Channel的概念，为了方便区分，这里及后续的分析中都将Netty中的称为Channel，而NIO中的称为JavaChannel。</strong> Channel是Netty中的核心概念之一，表示的是客户端或服务端与远程主机通讯的某个Socket。在大多数语言的网络通讯库中，客户端中只有一种Socket，但在服务端中有两种：ServerSocket和Socket，前者只负责监听端口，后者负责处理与远程主机的数据交换。 至于服务端为什么要使用两种Socket，我认为还是受限于OS系统调用的接口定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel = channelFactory.newChannel();</span><br></pre></td></tr></table></figure><p>和Spring等一众Java框架类似，对于核心概念的实例化采用了工厂模式。<code>ChannelFactory</code>接口结构很简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ChannelFactory</span><<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Channel</span>> </span>{</span><br><span class="line">    <span class="function">T <span class="title">newChannel</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/5c8854379f983db74506487c2d562e67.png" alt> 实现了<code>ChannelFactory</code>接口的类不多，工厂对象的实际类型多半就是<code>ReflectiveChannelFactory</code>了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReflectiveChannelFactory</span><span class="params">(Class<? extends T> clazz)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.clazz = clazz;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">newChannel</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> clazz.getConstructor().newInstance();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>ReflectiveChannelFactory</code>在构造函数中拿到了<code>channel</code>的类型，然后使用了反射构造函数来实例化对象，没毛病。至于它的构造函数是在何处调用的，在server启动代码链式调用<code>bootstrap</code>的数个方法中，有这么一个方法设置了<code>channel</code>的类型（准确地说是Class对象）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channel</span><span class="params">(Class<? extends C> channelClass)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> channelFactory(<span class="keyword">new</span> ReflectiveChannelFactory<C>(channelClass));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> B <span class="title">channelFactory</span><span class="params">(ChannelFactory<? extends C> channelFactory)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>.channelFactory = channelFactory;</span><br><span class="line">    <span class="keyword">return</span> self();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里<code>ReflectiveChannelFactory</code>是直接new出来的，没有通过反射，传入构造函数的参数为<code>channel</code>的类型。<code>AbstractBootstrap</code>简单的实例化了一个<code>channelFactory</code>，并关联到该对象自身。 <strong>貌似Netty中很多的setter方法都是这种写法。</strong> <strong><code>channel</code>实例化的过程还是挺简单的：在<code>bootstrap</code>的链式调用中实例化<code>channelFactory</code>，然后在server启动监听时有工厂实例化真正的<code>channel</code>。</strong></p><h2 id="初始化channel"><a href="#初始化channel" class="headerlink" title="初始化channel"></a>初始化channel</h2><p><code>AbstractBootstrap</code>的<code>init</code>方法是抽象的，该方法的实现被下放到了子类中去：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">final</span> Map<ChannelOption<?>, Object> options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) {</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map<AttributeKey<?>, Object> attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) {</span><br><span class="line">        <span class="keyword">for</span> (Entry<AttributeKey<?>, Object> e: attrs.entrySet()) {</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            AttributeKey<Object> key = (AttributeKey<Object>) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    ChannelPipeline p = channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> EventLoopGroup currentChildGroup = childGroup;</span><br><span class="line">    <span class="keyword">final</span> ChannelHandler currentChildHandler = childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry<ChannelOption<?>, Object>[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry<AttributeKey<?>, Object>[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) {</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) {</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    p.addLast(<span class="keyword">new</span> ChannelInitializer<Channel>() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">            <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">            ChannelHandler handler = config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="keyword">null</span>) {</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                }</span><br><span class="line">            });</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><ol><li>将<code>AbstractBootstrap</code>负责维护的<code>options</code>和<code>attrs</code>无脑地全部设置到<code>channel</code>对象上去。为了避免另一个线程修改<code>options</code>和<code>attrs</code>，访问时都进行了同步，我认为这里的加锁在服务器启动阶段是不会对性能造成太大影响的。</li><li>在该channel的<code>pipeline</code>尾部添加一个<code>ChannelInitializer</code>，何时调用其<code>initChannel</code>方法目前还不得而知，但是该<code>ChannelInitializer</code>的目的还是挺明确的： 2.1. 在<code>pipeline</code>尾部添加一个<code>ChannelHandler</code>。 2.2. 在该<code>channel</code>的线程中，异步地在其<code>pipeline</code>尾部添加一个<code>ServerBootstrapAcceptor</code>。</li></ol><h2 id="注册channel"><a href="#注册channel" class="headerlink" title="注册channel"></a>注册channel</h2><p><code>ChannelFuture regFuture = config().group().register(channel);</code> <code>group()</code>返回的是<code>EventLoopGroup</code>，即线程组，Netty中一个<code>EventLoop</code>即为一个线程，将多个线程组合起来管理就产生了“线程组”的概念（和OS中的线程组概念不同）。这里调用了<code>EventLoopGroup</code>接口里的<code>register</code>方法来注册<code>channel</code>，但暂时还无法判断是哪个实现了<code>EventLoopGroup</code>接口的小可爱。 在这一行代码加断点并以调试模式运行Echo Example。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/d94b109dc5c60ed0de2b23e7417abb6c.png" alt> 发现<code>config().group()</code>返回的是一个<code>NioEventLoopGroup</code>对象，这个对象是<code>MultithreadEventLoopGroup</code>的子类，其<code>register</code>方法所做之事很简单。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> next().register(channel);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>next()</code>方法返回了一个<code>EventLoop</code>，根据直觉猜测<code>EventLoopGroup</code>是一个可迭代的对象，其中存放了<code>EventLoop</code>的列表，而<code>next()</code>方法类似于迭代器的<code>next()</code>方法，返回下一个<code>EventLoop</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> EventExecutor <span class="title">next</span><span class="params">()</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> chooser.next();</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>MultithreadEventLoopGroup</code>的<code>next()</code>方法最终会借助于<code>chooser</code>返回下一个<code>EventLoop</code>对象。暂时还不知道这个chooser是何方神圣，只知道他是<code>MultithreadEventLoopGroup</code>维护的众多对象之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutor[] children;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set<EventExecutor> readonlyChildren;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger terminatedChildren = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Promise<?> terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> EventExecutorChooserFactory.EventExecutorChooser chooser;</span><br></pre></td></tr></table></figure><p>由于目前我们还只是专注于启动流程，而启动过程中线程的选择与切换的特点还不能很好地显现出来，因此先不管<code>chooser</code>，回到<code>register</code>方法中。 <code>next()</code>返回了一个<code>SingleThreadEventLoop</code>对象，通知他调用他自己实现的<code>register</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> register(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>));</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里实例化了一个<code>DefaultChannelPromise</code>，并把<code>channel</code>和<code>SingleThreadEventLoop</code>作为参数传入，估计<code>Promise</code>会把他们两人关联起来。 <img src="https://kherrisanbucketone.oss-cn-shanghai.aliyuncs.com/d2d80e9027d11fab989d4dc9f3f2b4c1.png" alt> 如果忘记了<code>channel</code>是什么东西的话，可以回溯到<code>ChannelFactory</code>的部分：<code>ChannelFactory</code>通过反射实例化<code>channel</code>对象，而其类型就是在<code>bootstrap</code>对象上进行方法链式调用时传入的<code>NioServerSocketChannel.class</code>。 实例化promise后并没有结束，因为还没有注册呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(<span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">    promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">    <span class="keyword">return</span> promise;</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>此时<code>promise.channel()</code>返回的就是刚才传入构造函数的<code>NioServerSocketChannel</code>。<code>unsafe</code>是个什么玩意儿还不是很清楚，但联想到JDK中有一个也叫<code>Unsafe</code>的组件，用于提供对内存的直接操作，就可以猜测这个<code>unsafe</code>应该是负责某些底层操作流程的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">            ......</span><br><span class="line">            AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;<span class="comment">//从此这个channel有了属于自己的eventloop</span></span><br><span class="line">            <span class="keyword">if</span> (eventLoop.inEventLoop()) {</span><br><span class="line">                register0(promise);</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                    eventLoop.execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                            register0(promise);</span><br><span class="line">                        }</span><br><span class="line">                    });</span><br><span class="line">                    ......</span><br><span class="line">            }</span><br><span class="line">        }</span><br></pre></td></tr></table></figure><p><code>unsafe</code>的<code>register</code>方法的主要内容如上，最终目的是调用<code>register0</code>方法，注册<code>promise</code>。直觉告诉我，名字里带0的方法都差不多快要到终点了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>{</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        ......</span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        ......</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        <span class="keyword">if</span> (isActive()) {</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) {</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            } <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) {</span><br><span class="line">                beginRead();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        ......</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>除了触发了几个事件之外，最神秘的当属<code>doRegister</code>方法，直觉告诉我，当看到带有do字样的方法的时候，就离终点不远了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doRegister</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">boolean</span> selected = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (;;) {</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="number">0</span>, <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        } <span class="keyword">catch</span> (CancelledKeyException e) {</span><br><span class="line">            <span class="keyword">if</span> (!selected) {</span><br><span class="line">                <span class="comment">// Force the Selector to select now as the "canceled" SelectionKey may still be</span></span><br><span class="line">                <span class="comment">// cached and not removed because no Select.select(..) operation was called yet.</span></span><br><span class="line">                eventLoop().selectNow();</span><br><span class="line">                selected = <span class="keyword">true</span>;</span><br><span class="line">            } <span class="keyword">else</span> {</span><br><span class="line">                <span class="comment">// We forced a select operation on the selector before but the SelectionKey is still cached</span></span><br><span class="line">                <span class="comment">// for whatever reason. JDK bug ?</span></span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>doRegister</code>的主体是一个死循环，虽然这个死循环只会重复一到两次，在<code>javaChannel</code>上注册<code>selector</code>以及感兴趣的事件，同时，由于<code>AbstractNioChannel</code>本身是一个<code>AttributeMap</code>，因此自己作为属性的持有者也被注册到了<code>javaChannel</code>上。 这个<code>register</code>方法以及属于<code>java.nio</code>中的代码，总算可以说到终点了。 现在回到<code>AbstractBootstrap</code>的<code>doBind0</code>方法。</p><h2 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doBind0</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> Runnable() {</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                ......</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">                ......</span><br><span class="line">        }</span><br><span class="line">    });</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>doBind0</code>在另一个线程中将监听的地址绑定到<code>channel</code>上去，猜测这个<code>channel</code>应该是一个<code>NioServerSocketChannel</code>。然而并不是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelFuture <span class="title">bind</span><span class="params">(SocketAddress localAddress, ChannelPromise promise)</span> </span>{</span><br><span class="line">    <span class="keyword">return</span> tail.bind(localAddress, promise);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>netty试图找到<code>pipline</code>上的最后一个<code>OutboundHandler</code>，这个<code>handler</code>有一个与之关联的<code>HeadContext</code>，它的<code>bind</code>方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    unsafe.bind(localAddress, promise);</span><br><span class="line">}</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> </span>{</span><br><span class="line">    ......</span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">if</span> (!wasActive && isActive()) {</span><br><span class="line">        invokeLater(<span class="keyword">new</span> Runnable() {</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p><code>unsafe</code>的<code>bind</code>方法在调用<code>doBind</code>同时，不忘发起一个<code>channelActive</code>事件。 最终让<code>javaChannel</code>监听该地址：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() >= <span class="number">7</span>) {</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    } <span class="keyword">else</span> {</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>注意到，此时<code>javaChannel</code>上的<code>interestOps</code>只有0，也就是无论<code>channel</code>上发生什么事件，都不会被<code>selector</code>选中，作为一个服务器，是肯定要处理<code>ACCEPT</code>事件的，在<code>pipeline.fireChannelActive()</code>中，经过<code>pipline</code>，调用到了<code>unsafe.beginRead()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>{</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps & readInterestOp) == <span class="number">0</span>) {</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></table></figure><p>这里的<code>readInterestOp</code>的值为16，对应的java nio中的<code>OP_ACCEPT</code>。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>netty启动过程还是很复杂的，启动过程总结如下：</p><ol><li><code>channelFactory</code>通过反射实例化<code>ServerSocketChannel</code>对象。</li><li>初始化<code>channel</code>的attrs和options。</li><li>要求新连接到来的时候，在<code>pipeline</code>尾部添加一个<code>ServerBootstrapAcceptor</code>。</li><li>选择一个<code>eventLoop</code>，注册到该<code>channel</code>上。</li><li>在<code>javaChannel</code>上注册这个<code>eventLoop</code>的<code>selector</code>。</li><li>触发<code>handlerAdded</code>和<code>channelRegistered</code>事件。</li><li>将<code>javaChannel</code>绑定到指定的地址和端口上去。</li><li>触发<code>channelActivated</code>事件。</li><li>注册<code>OP_ACCEPT</code>到<code>selector</code>上去。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以netty-example中的Echo（Server）为例，分析Netty源码的结构与运行过程。 跳过SSL相关的部分。从下面这一行代码开始：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ChannelFuture f = b.bind(PORT).sync();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Netty" scheme="http://www.kherrisan.cn/categories/Netty/"/>
    
    
      <category term="java" scheme="http://www.kherrisan.cn/tags/java/"/>
    
      <category term="Netty" scheme="http://www.kherrisan.cn/tags/Netty/"/>
    
  </entry>
  
</feed>
